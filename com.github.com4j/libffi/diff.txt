? ChangeLog.win64
? README.jna
? autom4te.cache
? build
? build64
? config.h.in
? diff.txt
? diff2.txt
? files.txt
? tdiff.txt
? testsuite-patch.diff
? up.out
? up.txt
? update.txt
? w32-patch.txt
? w64-patch.txt
? win64-patch.diff
? win64-patch.txt
? src/x86/ffi.c.kai
? src/x86/ffi.c.new
? src/x86/ffi.c.works
? src/x86/win64.S.new
? testsuite/lib/libffi-dg.exp.mod
? testsuite/libffi.call/call.exp.mod
Index: ChangeLog.libffi
===================================================================
RCS file: /cvs/libffi/libffi/ChangeLog.libffi,v
retrieving revision 1.50
diff -u -b -w -r1.50 ChangeLog.libffi
--- ChangeLog.libffi	4 Jun 2009 16:29:58 -0000	1.50
+++ ChangeLog.libffi	10 Jun 2009 10:29:26 -0000
@@ -1,3 +1,117 @@
+2009-06-08  Timothy Wall  <twall@users.sf.net>
+
+	* Makefile.am,
+        configure.ac,
+        include/ffi.h.in,
+        include/ffi_common.h,
+        src/closures.c,
+        src/dlmalloc.c,
+        src/x86/ffi.c,
+        src/x86/ffitarget.h,
+        src/x86/win64.S (new),
+	README: Added win64 support (mingw or MSVC)
+        * Makefile.in,
+        include/Makefile.in,
+        man/Makefile.in,
+        testsuite/Makefile.in,
+        configure,
+        aclocal.m4: Regenerated
+        * ltcf-c.sh: properly escape cygwin/w32 path
+        * man/ffi_call.3: Clarify size requirements for return value.
+        * src/x86/ffi64.c: Fix filename in comment.
+        * src/x86/win32.S: Remove global reference which causes undefined
+        symbol warning.
+
+        * testsuite/libffi.call/closure_fn0.c,
+        testsuite/libffi.call/closure_fn1.c,
+        testsuite/libffi.call/closure_fn2.c,
+        testsuite/libffi.call/closure_fn3.c,
+        testsuite/libffi.call/closure_fn4.c,
+        testsuite/libffi.call/closure_fn5.c,
+        testsuite/libffi.call/closure_fn6.c,
+	testsuite/libffi.call/closure_stdcall.c,
+	testsuite/libffi.call/cls_12byte.c,
+	testsuite/libffi.call/cls_16byte.c,
+	testsuite/libffi.call/cls_18byte.c,
+	testsuite/libffi.call/cls_19byte.c,
+	testsuite/libffi.call/cls_1_1byte.c,
+	testsuite/libffi.call/cls_20byte.c,
+	testsuite/libffi.call/cls_20byte1.c,
+	testsuite/libffi.call/cls_24byte.c,
+	testsuite/libffi.call/cls_2byte.c,
+	testsuite/libffi.call/cls_3_1byte.c,
+	testsuite/libffi.call/cls_3byte1.c,
+ 	testsuite/libffi.call/cls_3byte2.c,
+ 	testsuite/libffi.call/cls_4_1byte.c,
+ 	testsuite/libffi.call/cls_4byte.c,
+ 	testsuite/libffi.call/cls_5_1_byte.c,
+ 	testsuite/libffi.call/cls_5byte.c,
+ 	testsuite/libffi.call/cls_64byte.c,
+ 	testsuite/libffi.call/cls_6_1_byte.c,
+ 	testsuite/libffi.call/cls_6byte.c,
+ 	testsuite/libffi.call/cls_7_1_byte.c,
+ 	testsuite/libffi.call/cls_7byte.c,
+ 	testsuite/libffi.call/cls_8byte.c,
+ 	testsuite/libffi.call/cls_9byte1.c,
+ 	testsuite/libffi.call/cls_9byte2.c,
+ 	testsuite/libffi.call/cls_align_double.c,
+ 	testsuite/libffi.call/cls_align_float.c,
+ 	testsuite/libffi.call/cls_align_longdouble.c,
+ 	testsuite/libffi.call/cls_align_longdouble_split.c,
+ 	testsuite/libffi.call/cls_align_longdouble_split2.c,
+ 	testsuite/libffi.call/cls_align_pointer.c,
+ 	testsuite/libffi.call/cls_align_sint16.c,
+ 	testsuite/libffi.call/cls_align_sint32.c,
+ 	testsuite/libffi.call/cls_align_sint64.c,
+ 	testsuite/libffi.call/cls_align_uint16.c,
+ 	testsuite/libffi.call/cls_align_uint32.c,
+ 	testsuite/libffi.call/cls_align_uint64.c,
+ 	testsuite/libffi.call/cls_dbls_struct.c,
+ 	testsuite/libffi.call/cls_double.c,
+ 	testsuite/libffi.call/cls_double_va.c,
+ 	testsuite/libffi.call/cls_float.c,
+ 	testsuite/libffi.call/cls_longdouble.c,
+ 	testsuite/libffi.call/cls_longdouble_va.c,
+ 	testsuite/libffi.call/cls_multi_schar.c,
+ 	testsuite/libffi.call/cls_multi_sshort.c,
+ 	testsuite/libffi.call/cls_multi_sshortchar.c,
+ 	testsuite/libffi.call/cls_multi_uchar.c,
+ 	testsuite/libffi.call/cls_multi_ushort.c,
+ 	testsuite/libffi.call/cls_multi_ushortchar.c,
+ 	testsuite/libffi.call/cls_pointer.c,
+ 	testsuite/libffi.call/cls_pointer_stack.c,
+ 	testsuite/libffi.call/cls_schar.c,
+ 	testsuite/libffi.call/cls_sint.c,
+ 	testsuite/libffi.call/cls_sshort.c,
+ 	testsuite/libffi.call/cls_uchar.c,
+ 	testsuite/libffi.call/cls_uint.c,
+ 	testsuite/libffi.call/cls_ulonglong.c,
+ 	testsuite/libffi.call/cls_ushort.c,
+ 	testsuite/libffi.call/err_bad_abi.c,
+ 	testsuite/libffi.call/err_bad_typedef.c,
+ 	testsuite/libffi.call/float2.c,
+ 	testsuite/libffi.call/huge_struct.c,
+ 	testsuite/libffi.call/nested_struct.c,
+ 	testsuite/libffi.call/nested_struct1.c,
+ 	testsuite/libffi.call/nested_struct10.c,
+ 	testsuite/libffi.call/nested_struct2.c,
+ 	testsuite/libffi.call/nested_struct3.c,
+ 	testsuite/libffi.call/nested_struct4.c,
+ 	testsuite/libffi.call/nested_struct5.c,
+ 	testsuite/libffi.call/nested_struct6.c,
+ 	testsuite/libffi.call/nested_struct7.c,
+ 	testsuite/libffi.call/nested_struct8.c,
+ 	testsuite/libffi.call/nested_struct9.c,
+ 	testsuite/libffi.call/problem1.c,
+ 	testsuite/libffi.call/return_ldl.c,
+ 	testsuite/libffi.call/return_ll1.c,
+ 	testsuite/libffi.call/stret_large.c,
+ 	testsuite/libffi.call/stret_large2.c,
+ 	testsuite/libffi.call/stret_medium.c,
+ 	testsuite/libffi.call/stret_medium2.c,
+        testsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead
+        of checking for MMAP.  Use intptr_t instead of long casts.
+
 2009-06-04  Andrew Haley  <aph@redhat.com>
 
 	* src/powerpc/ffitarget.h: Fix misapplied merge from gcc.
Index: Makefile.am
===================================================================
RCS file: /cvs/libffi/libffi/Makefile.am,v
retrieving revision 1.23
diff -u -b -w -r1.23 Makefile.am
--- Makefile.am	21 Feb 2008 13:36:18 -0000	1.23
+++ Makefile.am	10 Jun 2009 10:29:26 -0000
@@ -25,8 +25,8 @@
 	src/sh64/ffi.c src/sh64/sysv.S src/sh64/ffitarget.h \
 	src/sparc/v8.S src/sparc/v9.S src/sparc/ffitarget.h \
 	src/sparc/ffi.c src/x86/darwin64.S \
-	src/x86/ffi.c src/x86/sysv.S src/x86/win32.S src/x86/darwin.S \
-	src/x86/freebsd.S \
+	src/x86/ffi.c src/x86/sysv.S src/x86/win32.S src/x86/win64.S \
+	src/x86/darwin.S src/x86/freebsd.S \
 	src/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \
 	src/pa/ffitarget.h src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \
 	src/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c \
@@ -102,6 +102,9 @@
 if X86_WIN32
 nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/win32.S
 endif
+if X86_WIN64
+nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/win64.S
+endif
 if X86_DARWIN
 nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S
 endif
Index: Makefile.in
===================================================================
RCS file: /cvs/libffi/libffi/Makefile.in,v
retrieving revision 1.26
diff -u -b -w -r1.26 Makefile.in
--- Makefile.in	19 Dec 2008 15:47:44 -0000	1.26
+++ Makefile.in	10 Jun 2009 10:29:26 -0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -38,25 +38,26 @@
 @X86_TRUE@am__append_2 = src/x86/ffi.c src/x86/sysv.S
 @X86_FREEBSD_TRUE@am__append_3 = src/x86/ffi.c src/x86/freebsd.S
 @X86_WIN32_TRUE@am__append_4 = src/x86/ffi.c src/x86/win32.S
-@X86_DARWIN_TRUE@am__append_5 = src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S
-@SPARC_TRUE@am__append_6 = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S
-@ALPHA_TRUE@am__append_7 = src/alpha/ffi.c src/alpha/osf.S
-@IA64_TRUE@am__append_8 = src/ia64/ffi.c src/ia64/unix.S
-@M32R_TRUE@am__append_9 = src/m32r/sysv.S src/m32r/ffi.c
-@M68K_TRUE@am__append_10 = src/m68k/ffi.c src/m68k/sysv.S
-@POWERPC_TRUE@am__append_11 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S
-@POWERPC_AIX_TRUE@am__append_12 = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S
-@POWERPC_DARWIN_TRUE@am__append_13 = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S
-@POWERPC_FREEBSD_TRUE@am__append_14 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S
-@ARM_TRUE@am__append_15 = src/arm/sysv.S src/arm/ffi.c
-@LIBFFI_CRIS_TRUE@am__append_16 = src/cris/sysv.S src/cris/ffi.c
-@FRV_TRUE@am__append_17 = src/frv/eabi.S src/frv/ffi.c
-@S390_TRUE@am__append_18 = src/s390/sysv.S src/s390/ffi.c
-@X86_64_TRUE@am__append_19 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S
-@SH_TRUE@am__append_20 = src/sh/sysv.S src/sh/ffi.c
-@SH64_TRUE@am__append_21 = src/sh64/sysv.S src/sh64/ffi.c
-@PA_LINUX_TRUE@am__append_22 = src/pa/linux.S src/pa/ffi.c
-@PA_HPUX_TRUE@am__append_23 = src/pa/hpux32.S src/pa/ffi.c
+@X86_WIN64_TRUE@am__append_5 = src/x86/ffi.c src/x86/win64.S
+@X86_DARWIN_TRUE@am__append_6 = src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S
+@SPARC_TRUE@am__append_7 = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S
+@ALPHA_TRUE@am__append_8 = src/alpha/ffi.c src/alpha/osf.S
+@IA64_TRUE@am__append_9 = src/ia64/ffi.c src/ia64/unix.S
+@M32R_TRUE@am__append_10 = src/m32r/sysv.S src/m32r/ffi.c
+@M68K_TRUE@am__append_11 = src/m68k/ffi.c src/m68k/sysv.S
+@POWERPC_TRUE@am__append_12 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S
+@POWERPC_AIX_TRUE@am__append_13 = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S
+@POWERPC_DARWIN_TRUE@am__append_14 = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S
+@POWERPC_FREEBSD_TRUE@am__append_15 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S
+@ARM_TRUE@am__append_16 = src/arm/sysv.S src/arm/ffi.c
+@LIBFFI_CRIS_TRUE@am__append_17 = src/cris/sysv.S src/cris/ffi.c
+@FRV_TRUE@am__append_18 = src/frv/eabi.S src/frv/ffi.c
+@S390_TRUE@am__append_19 = src/s390/sysv.S src/s390/ffi.c
+@X86_64_TRUE@am__append_20 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S
+@SH_TRUE@am__append_21 = src/sh/sysv.S src/sh/ffi.c
+@SH64_TRUE@am__append_22 = src/sh64/sysv.S src/sh64/ffi.c
+@PA_LINUX_TRUE@am__append_23 = src/pa/linux.S src/pa/ffi.c
+@PA_HPUX_TRUE@am__append_24 = src/pa/hpux32.S src/pa/ffi.c
 subdir = .
 DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in $(srcdir)/doc/stamp-vti \
@@ -94,37 +95,38 @@
 @X86_TRUE@am__objects_2 = src/x86/ffi.lo src/x86/sysv.lo
 @X86_FREEBSD_TRUE@am__objects_3 = src/x86/ffi.lo src/x86/freebsd.lo
 @X86_WIN32_TRUE@am__objects_4 = src/x86/ffi.lo src/x86/win32.lo
-@X86_DARWIN_TRUE@am__objects_5 = src/x86/ffi.lo src/x86/darwin.lo \
+@X86_WIN64_TRUE@am__objects_5 = src/x86/ffi.lo src/x86/win64.lo
+@X86_DARWIN_TRUE@am__objects_6 = src/x86/ffi.lo src/x86/darwin.lo \
 @X86_DARWIN_TRUE@	src/x86/ffi64.lo src/x86/darwin64.lo
-@SPARC_TRUE@am__objects_6 = src/sparc/ffi.lo src/sparc/v8.lo \
+@SPARC_TRUE@am__objects_7 = src/sparc/ffi.lo src/sparc/v8.lo \
 @SPARC_TRUE@	src/sparc/v9.lo
-@ALPHA_TRUE@am__objects_7 = src/alpha/ffi.lo src/alpha/osf.lo
-@IA64_TRUE@am__objects_8 = src/ia64/ffi.lo src/ia64/unix.lo
-@M32R_TRUE@am__objects_9 = src/m32r/sysv.lo src/m32r/ffi.lo
-@M68K_TRUE@am__objects_10 = src/m68k/ffi.lo src/m68k/sysv.lo
-@POWERPC_TRUE@am__objects_11 = src/powerpc/ffi.lo src/powerpc/sysv.lo \
+@ALPHA_TRUE@am__objects_8 = src/alpha/ffi.lo src/alpha/osf.lo
+@IA64_TRUE@am__objects_9 = src/ia64/ffi.lo src/ia64/unix.lo
+@M32R_TRUE@am__objects_10 = src/m32r/sysv.lo src/m32r/ffi.lo
+@M68K_TRUE@am__objects_11 = src/m68k/ffi.lo src/m68k/sysv.lo
+@POWERPC_TRUE@am__objects_12 = src/powerpc/ffi.lo src/powerpc/sysv.lo \
 @POWERPC_TRUE@	src/powerpc/ppc_closure.lo \
 @POWERPC_TRUE@	src/powerpc/linux64.lo \
 @POWERPC_TRUE@	src/powerpc/linux64_closure.lo
-@POWERPC_AIX_TRUE@am__objects_12 = src/powerpc/ffi_darwin.lo \
+@POWERPC_AIX_TRUE@am__objects_13 = src/powerpc/ffi_darwin.lo \
 @POWERPC_AIX_TRUE@	src/powerpc/aix.lo \
 @POWERPC_AIX_TRUE@	src/powerpc/aix_closure.lo
-@POWERPC_DARWIN_TRUE@am__objects_13 = src/powerpc/ffi_darwin.lo \
+@POWERPC_DARWIN_TRUE@am__objects_14 = src/powerpc/ffi_darwin.lo \
 @POWERPC_DARWIN_TRUE@	src/powerpc/darwin.lo \
 @POWERPC_DARWIN_TRUE@	src/powerpc/darwin_closure.lo
-@POWERPC_FREEBSD_TRUE@am__objects_14 = src/powerpc/ffi.lo \
+@POWERPC_FREEBSD_TRUE@am__objects_15 = src/powerpc/ffi.lo \
 @POWERPC_FREEBSD_TRUE@	src/powerpc/sysv.lo \
 @POWERPC_FREEBSD_TRUE@	src/powerpc/ppc_closure.lo
-@ARM_TRUE@am__objects_15 = src/arm/sysv.lo src/arm/ffi.lo
-@LIBFFI_CRIS_TRUE@am__objects_16 = src/cris/sysv.lo src/cris/ffi.lo
-@FRV_TRUE@am__objects_17 = src/frv/eabi.lo src/frv/ffi.lo
-@S390_TRUE@am__objects_18 = src/s390/sysv.lo src/s390/ffi.lo
-@X86_64_TRUE@am__objects_19 = src/x86/ffi64.lo src/x86/unix64.lo \
+@ARM_TRUE@am__objects_16 = src/arm/sysv.lo src/arm/ffi.lo
+@LIBFFI_CRIS_TRUE@am__objects_17 = src/cris/sysv.lo src/cris/ffi.lo
+@FRV_TRUE@am__objects_18 = src/frv/eabi.lo src/frv/ffi.lo
+@S390_TRUE@am__objects_19 = src/s390/sysv.lo src/s390/ffi.lo
+@X86_64_TRUE@am__objects_20 = src/x86/ffi64.lo src/x86/unix64.lo \
 @X86_64_TRUE@	src/x86/ffi.lo src/x86/sysv.lo
-@SH_TRUE@am__objects_20 = src/sh/sysv.lo src/sh/ffi.lo
-@SH64_TRUE@am__objects_21 = src/sh64/sysv.lo src/sh64/ffi.lo
-@PA_LINUX_TRUE@am__objects_22 = src/pa/linux.lo src/pa/ffi.lo
-@PA_HPUX_TRUE@am__objects_23 = src/pa/hpux32.lo src/pa/ffi.lo
+@SH_TRUE@am__objects_21 = src/sh/sysv.lo src/sh/ffi.lo
+@SH64_TRUE@am__objects_22 = src/sh64/sysv.lo src/sh64/ffi.lo
+@PA_LINUX_TRUE@am__objects_23 = src/pa/linux.lo src/pa/ffi.lo
+@PA_HPUX_TRUE@am__objects_24 = src/pa/hpux32.lo src/pa/ffi.lo
 nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \
 	$(am__objects_3) $(am__objects_4) $(am__objects_5) \
 	$(am__objects_6) $(am__objects_7) $(am__objects_8) \
@@ -132,25 +134,26 @@
 	$(am__objects_12) $(am__objects_13) $(am__objects_14) \
 	$(am__objects_15) $(am__objects_16) $(am__objects_17) \
 	$(am__objects_18) $(am__objects_19) $(am__objects_20) \
-	$(am__objects_21) $(am__objects_22) $(am__objects_23)
+	$(am__objects_21) $(am__objects_22) $(am__objects_23) \
+	$(am__objects_24)
 libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) \
 	$(nodist_libffi_la_OBJECTS)
 libffi_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(libffi_la_LDFLAGS) $(LDFLAGS) -o $@
 libffi_convenience_la_LIBADD =
-am__objects_24 = src/debug.lo src/prep_cif.lo src/types.lo \
+am__objects_25 = src/debug.lo src/prep_cif.lo src/types.lo \
 	src/raw_api.lo src/java_raw_api.lo src/closures.lo
-am_libffi_convenience_la_OBJECTS = $(am__objects_24)
-am__objects_25 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \
+am_libffi_convenience_la_OBJECTS = $(am__objects_25)
+am__objects_26 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \
 	$(am__objects_4) $(am__objects_5) $(am__objects_6) \
 	$(am__objects_7) $(am__objects_8) $(am__objects_9) \
 	$(am__objects_10) $(am__objects_11) $(am__objects_12) \
 	$(am__objects_13) $(am__objects_14) $(am__objects_15) \
 	$(am__objects_16) $(am__objects_17) $(am__objects_18) \
 	$(am__objects_19) $(am__objects_20) $(am__objects_21) \
-	$(am__objects_22) $(am__objects_23)
-nodist_libffi_convenience_la_OBJECTS = $(am__objects_25)
+	$(am__objects_22) $(am__objects_23) $(am__objects_24)
+nodist_libffi_convenience_la_OBJECTS = $(am__objects_26)
 libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \
 	$(nodist_libffi_convenience_la_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
@@ -358,8 +361,8 @@
 	src/sh64/ffi.c src/sh64/sysv.S src/sh64/ffitarget.h \
 	src/sparc/v8.S src/sparc/v9.S src/sparc/ffitarget.h \
 	src/sparc/ffi.c src/x86/darwin64.S \
-	src/x86/ffi.c src/x86/sysv.S src/x86/win32.S src/x86/darwin.S \
-	src/x86/freebsd.S \
+	src/x86/ffi.c src/x86/sysv.S src/x86/win32.S src/x86/win64.S \
+	src/x86/darwin.S src/x86/freebsd.S \
 	src/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \
 	src/pa/ffitarget.h src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \
 	src/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c \
@@ -419,7 +422,8 @@
 	$(am__append_12) $(am__append_13) $(am__append_14) \
 	$(am__append_15) $(am__append_16) $(am__append_17) \
 	$(am__append_18) $(am__append_19) $(am__append_20) \
-	$(am__append_21) $(am__append_22) $(am__append_23)
+	$(am__append_21) $(am__append_22) $(am__append_23) \
+	$(am__append_24)
 libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)
 nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)
 AM_CFLAGS = -Wall -g -fexceptions
@@ -557,6 +561,8 @@
 	src/x86/$(DEPDIR)/$(am__dirstamp)
 src/x86/win32.lo: src/x86/$(am__dirstamp) \
 	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/win64.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
 src/x86/darwin.lo: src/x86/$(am__dirstamp) \
 	src/x86/$(DEPDIR)/$(am__dirstamp)
 src/x86/ffi64.lo: src/x86/$(am__dirstamp) \
@@ -826,6 +832,8 @@
 	-rm -f src/x86/unix64.lo
 	-rm -f src/x86/win32.$(OBJEXT)
 	-rm -f src/x86/win32.lo
+	-rm -f src/x86/win64.$(OBJEXT)
+	-rm -f src/x86/win64.lo
 
 distclean-compile:
 	-rm -f *.tab.c
@@ -883,6 +891,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/sysv.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/unix64.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/win32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/win64.Plo@am__quote@
 
 .S.o:
 @am__fastdepCCAS_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
@@ -955,7 +964,7 @@
 	-rm -rf src/x86/.libs src/x86/_libs
 
 distclean-libtool:
-	-rm -f libtool
+	-rm -f libtool config.lt
 doc/$(am__dirstamp):
 	@$(MKDIR_P) doc
 	@: > doc/$(am__dirstamp)
@@ -1206,7 +1215,7 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
 	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	mkid -fID $$unique
 tags: TAGS
Index: README
===================================================================
RCS file: /cvs/libffi/libffi/README,v
retrieving revision 1.27
diff -u -b -w -r1.27 README
--- README	19 Dec 2008 16:13:45 -0000	1.27
+++ README	10 Jun 2009 10:29:26 -0000
@@ -58,6 +58,7 @@
      x86 linux
      x86 openbsd
      x86 solaris
+     x86-64 mingw
      x86-64 darwin
      x86-64 linux
      x86-64 OS X
Index: aclocal.m4
===================================================================
RCS file: /cvs/libffi/libffi/aclocal.m4,v
retrieving revision 1.9
diff -u -b -w -r1.9 aclocal.m4
--- aclocal.m4	19 Dec 2008 15:47:44 -0000	1.9
+++ aclocal.m4	10 Jun 2009 10:29:27 -0000
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.10.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.10.2 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 # 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
@@ -13,7 +13,7 @@
 
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(AC_AUTOCONF_VERSION, [2.63],,
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.63],,
 [m4_warning([this file was generated for autoconf 2.63.
 You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
@@ -645,7 +645,6 @@
       esac
       ;;
     *64-bit*)
-      libsuff=64
       case $host in
         x86_64-*kfreebsd*-gnu)
           LD="${LD-ld} -m elf_x86_64_fbsd"
@@ -1708,13 +1707,11 @@
   # Some rework will be needed to allow for fast_install
   # before this can be enabled.
   hardcode_into_libs=yes
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[ 	]*hwcap[ 	]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -6047,25 +6044,7 @@
       ;;
 
     darwin* | rhapsody*)
-      case $host_os in
-        rhapsody* | darwin1.[[012]])
-         _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}suppress'
-         ;;
-       *) # Darwin 1.3 on
-         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
-           _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-         else
-           case ${MACOSX_DEPLOYMENT_TARGET} in
-             10.[[012]])
-               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-               ;;
-             10.*)
-               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}dynamic_lookup'
-               ;;
-           esac
-         fi
-         ;;
-      esac
+      _LT_AC_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
       _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no
       _LT_AC_TAGVAR(hardcode_direct, $1)=no
       _LT_AC_TAGVAR(hardcode_automatic, $1)=yes
@@ -6658,7 +6637,7 @@
 AC_MSG_RESULT([$SED])
 ])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007  Free Software Foundation, Inc.
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -6673,7 +6652,7 @@
 [am__api_version='1.10'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.10.1], [],
+m4_if([$1], [1.10.2], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -6687,12 +6666,12 @@
 # AM_SET_CURRENT_AUTOMAKE_VERSION
 # -------------------------------
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
-# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.10.1])dnl
+[AM_AUTOMAKE_VERSION([1.10.2])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-_AM_AUTOCONF_VERSION(AC_AUTOCONF_VERSION)])
+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # Figure out how to run the assembler.                      -*- Autoconf -*-
 
@@ -6964,19 +6943,28 @@
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
 # Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-#serial 3
+#serial 4
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
 AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
-[for mf in $CONFIG_FILES; do
+[# Autoconf 2.62 quotes --file arguments for eval, but not when files
+# are listed without --file.  Let's play safe and only enable the eval
+# if we detect the quoting.
+case $CONFIG_FILES in
+*\'*) eval set x "$CONFIG_FILES" ;;
+*)   set x $CONFIG_FILES ;;
+esac
+shift
+for mf
+do
   # Strip MF so we end up with the name of the file.
   mf=`echo "$mf" | sed -e 's/:.*$//'`
   # Check whether this is an Automake generated Makefile or not.
@@ -7273,14 +7261,14 @@
 rm -f confinc confmf
 ])
 
-# Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005
+# Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2008
 # Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 6
 
 # AM_PROG_CC_C_O
 # --------------
@@ -7292,8 +7280,9 @@
 # FIXME: we rely on the cache variable name because
 # there is no other way.
 set dummy $CC
-ac_cc=`echo $[2] | sed ['s/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/']`
-if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" != yes"; then
+am_cc=`echo $[2] | sed ['s/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/']`
+eval am_t=\$ac_cv_prog_cc_${am_cc}_c_o
+if test "$am_t" != yes; then
    # Losing compiler, so override with the script.
    # FIXME: It is wrong to rewrite CC.
    # But if we don't then we get into trouble of one sort or another.
@@ -7371,13 +7360,13 @@
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 3
+# serial 4
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -7394,7 +7383,7 @@
 # ----------------------------------
 # OPTIONS is a space-separated list of Automake options.
 AC_DEFUN([_AM_SET_OPTIONS],
-[AC_FOREACH([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
 
 # _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
 # -------------------------------------------
Index: configure
===================================================================
RCS file: /cvs/libffi/libffi/configure,v
retrieving revision 1.34
diff -u -b -w -r1.34 configure
--- configure	19 Dec 2008 16:13:45 -0000	1.34
+++ configure	10 Jun 2009 10:29:30 -0000
@@ -836,6 +836,8 @@
 ALPHA_TRUE
 X86_DARWIN_FALSE
 X86_DARWIN_TRUE
+X86_WIN64_FALSE
+X86_WIN64_TRUE
 X86_WIN32_FALSE
 X86_WIN32_TRUE
 X86_FREEBSD_FALSE
@@ -4089,8 +4091,9 @@
 # FIXME: we rely on the cache variable name because
 # there is no other way.
 set dummy $CC
-ac_cc=`echo $2 | sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
-if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" != yes"; then
+am_cc=`echo $2 | sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
+eval am_t=\$ac_cv_prog_cc_${am_cc}_c_o
+if test "$am_t" != yes; then
    # Losing compiler, so override with the script.
    # FIXME: It is wrong to rewrite CC.
    # But if we don't then we get into trouble of one sort or another.
@@ -4797,7 +4800,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 4800 "configure"' > conftest.$ac_ext
+  echo '#line 4803 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -4862,7 +4865,6 @@
       esac
       ;;
     *64-bit*)
-      libsuff=64
       case $host in
         x86_64-*kfreebsd*-gnu)
           LD="${LD-ld} -m elf_x86_64_fbsd"
@@ -7883,11 +7885,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7886: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7888: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7890: \$? = $ac_status" >&5
+   echo "$as_me:7892: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8173,11 +8175,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8176: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8178: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8180: \$? = $ac_status" >&5
+   echo "$as_me:8182: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8277,11 +8279,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8280: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8282: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8284: \$? = $ac_status" >&5
+   echo "$as_me:8286: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -8918,25 +8920,7 @@
       ;;
 
     darwin* | rhapsody*)
-      case $host_os in
-        rhapsody* | darwin1.[012])
-         allow_undefined_flag='${wl}-undefined ${wl}suppress'
-         ;;
-       *) # Darwin 1.3 on
-         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
-           allow_undefined_flag='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-         else
-           case ${MACOSX_DEPLOYMENT_TARGET} in
-             10.[012])
-               allow_undefined_flag='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-               ;;
-             10.*)
-               allow_undefined_flag='${wl}-undefined ${wl}dynamic_lookup'
-               ;;
-           esac
-         fi
-         ;;
-      esac
+      allow_undefined_flag="$_lt_dar_allow_undefined"
       archive_cmds_need_lc=no
       hardcode_direct=no
       hardcode_automatic=yes
@@ -9793,13 +9777,11 @@
   # Some rework will be needed to allow for fast_install
   # before this can be enabled.
   hardcode_into_libs=yes
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[ 	]*hwcap[ 	]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -10679,7 +10661,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 10682 "configure"
+#line 10664 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10779,7 +10761,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 10782 "configure"
+#line 10764 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13188,11 +13170,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13191: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13173: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:13195: \$? = $ac_status" >&5
+   echo "$as_me:13177: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -13292,11 +13274,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13295: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13277: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:13299: \$? = $ac_status" >&5
+   echo "$as_me:13281: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -13794,13 +13776,11 @@
   # Some rework will be needed to allow for fast_install
   # before this can be enabled.
   hardcode_into_libs=yes
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[ 	]*hwcap[ 	]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -14877,11 +14857,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:14880: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:14860: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:14884: \$? = $ac_status" >&5
+   echo "$as_me:14864: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -14981,11 +14961,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:14984: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:14964: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:14988: \$? = $ac_status" >&5
+   echo "$as_me:14968: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -15602,25 +15582,7 @@
       ;;
 
     darwin* | rhapsody*)
-      case $host_os in
-        rhapsody* | darwin1.[012])
-         allow_undefined_flag_F77='${wl}-undefined ${wl}suppress'
-         ;;
-       *) # Darwin 1.3 on
-         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
-           allow_undefined_flag_F77='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-         else
-           case ${MACOSX_DEPLOYMENT_TARGET} in
-             10.[012])
-               allow_undefined_flag_F77='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-               ;;
-             10.*)
-               allow_undefined_flag_F77='${wl}-undefined ${wl}dynamic_lookup'
-               ;;
-           esac
-         fi
-         ;;
-      esac
+      allow_undefined_flag_F77="$_lt_dar_allow_undefined"
       archive_cmds_need_lc_F77=no
       hardcode_direct_F77=no
       hardcode_automatic_F77=yes
@@ -16425,13 +16387,11 @@
   # Some rework will be needed to allow for fast_install
   # before this can be enabled.
   hardcode_into_libs=yes
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[ 	]*hwcap[ 	]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -17198,11 +17158,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17201: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17161: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17205: \$? = $ac_status" >&5
+   echo "$as_me:17165: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -17488,11 +17448,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17491: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17451: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17495: \$? = $ac_status" >&5
+   echo "$as_me:17455: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -17592,11 +17552,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17595: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17555: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:17599: \$? = $ac_status" >&5
+   echo "$as_me:17559: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -18233,25 +18193,7 @@
       ;;
 
     darwin* | rhapsody*)
-      case $host_os in
-        rhapsody* | darwin1.[012])
-         allow_undefined_flag_GCJ='${wl}-undefined ${wl}suppress'
-         ;;
-       *) # Darwin 1.3 on
-         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
-           allow_undefined_flag_GCJ='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-         else
-           case ${MACOSX_DEPLOYMENT_TARGET} in
-             10.[012])
-               allow_undefined_flag_GCJ='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
-               ;;
-             10.*)
-               allow_undefined_flag_GCJ='${wl}-undefined ${wl}dynamic_lookup'
-               ;;
-           esac
-         fi
-         ;;
-      esac
+      allow_undefined_flag_GCJ="$_lt_dar_allow_undefined"
       archive_cmds_need_lc_GCJ=no
       hardcode_direct_GCJ=no
       hardcode_automatic_GCJ=yes
@@ -19056,13 +18998,11 @@
   # Some rework will be needed to allow for fast_install
   # before this can be enabled.
   hardcode_into_libs=yes
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[ 	]*hwcap[ 	]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -20968,6 +20908,10 @@
 	TARGET=X86_64; TARGETDIR=x86
   	;;
 
+  amd64-*-freebsd*)
+	TARGET=X86_64; TARGETDIR=x86
+	;;
+
   cris-*-*)
 	TARGET=LIBFFI_CRIS; TARGETDIR=cris
 	;;
@@ -21059,6 +21003,7 @@
 	TARGET=X86_DARWIN; TARGETDIR=x86
 	;;
   x86_64-*-cygwin* | x86_64-*-mingw*)
+	TARGET=X86_WIN64; TARGETDIR=x86
 	;;
   x86_64-*-*)
 	TARGET=X86_64; TARGETDIR=x86
@@ -21113,6 +21058,14 @@
   X86_WIN32_FALSE=
 fi
 
+ if test x$TARGET = xX86_WIN64; then
+  X86_WIN64_TRUE=
+  X86_WIN64_FALSE='#'
+else
+  X86_WIN64_TRUE='#'
+  X86_WIN64_FALSE=
+fi
+
  if test x$TARGET = xX86_DARWIN; then
   X86_DARWIN_TRUE=
   X86_DARWIN_FALSE='#'
@@ -23260,7 +23213,7 @@
     fi
 fi
 
-if test x$TARGET = xX86 || test x$TARGET = xX86_64; then
+if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64; then
     { $as_echo "$as_me:$LINENO: checking assembler supports pc related relocs" >&5
 $as_echo_n "checking assembler supports pc related relocs... " >&6; }
 if test "${libffi_cv_as_x86_pcrel+set}" = set; then
@@ -23619,6 +23572,13 @@
 Usually this means the macro was only invoked conditionally." >&2;}
    { (exit 1); exit 1; }; }
 fi
+if test -z "${X86_WIN64_TRUE}" && test -z "${X86_WIN64_FALSE}"; then
+  { { $as_echo "$as_me:$LINENO: error: conditional \"X86_WIN64\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+$as_echo "$as_me: error: conditional \"X86_WIN64\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 if test -z "${X86_DARWIN_TRUE}" && test -z "${X86_DARWIN_FALSE}"; then
   { { $as_echo "$as_me:$LINENO: error: conditional \"X86_DARWIN\" was never defined.
 Usually this means the macro was only invoked conditionally." >&5
@@ -24967,7 +24927,16 @@
 
 
   case $ac_file$ac_mode in
-    "depfiles":C) test x"$AMDEP_TRUE" != x"" || for mf in $CONFIG_FILES; do
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || # Autoconf 2.62 quotes --file arguments for eval, but not when files
+# are listed without --file.  Let's play safe and only enable the eval
+# if we detect the quoting.
+case $CONFIG_FILES in
+*\'*) eval set x "$CONFIG_FILES" ;;
+*)   set x $CONFIG_FILES ;;
+esac
+shift
+for mf
+do
   # Strip MF so we end up with the name of the file.
   mf=`echo "$mf" | sed -e 's/:.*$//'`
   # Check whether this is an Automake generated Makefile or not.
Index: configure.ac
===================================================================
RCS file: /cvs/libffi/libffi/configure.ac,v
retrieving revision 1.25
diff -u -b -w -r1.25 configure.ac
--- configure.ac	3 Jun 2009 17:42:56 -0000	1.25
+++ configure.ac	10 Jun 2009 10:29:30 -0000
@@ -148,6 +148,7 @@
 	TARGET=X86_DARWIN; TARGETDIR=x86
 	;;
   x86_64-*-cygwin* | x86_64-*-mingw*)
+	TARGET=X86_WIN64; TARGETDIR=x86
 	;;
   x86_64-*-*)
 	TARGET=X86_64; TARGETDIR=x86
@@ -165,6 +166,7 @@
 AM_CONDITIONAL(X86, test x$TARGET = xX86)
 AM_CONDITIONAL(X86_FREEBSD, test x$TARGET = xX86_FREEBSD)
 AM_CONDITIONAL(X86_WIN32, test x$TARGET = xX86_WIN32)
+AM_CONDITIONAL(X86_WIN64, test x$TARGET = xX86_WIN64)
 AM_CONDITIONAL(X86_DARWIN, test x$TARGET = xX86_DARWIN)
 AM_CONDITIONAL(ALPHA, test x$TARGET = xALPHA)
 AM_CONDITIONAL(IA64, test x$TARGET = xIA64)
Index: fficonfig.h.in
===================================================================
RCS file: /cvs/libffi/libffi/fficonfig.h.in,v
retrieving revision 1.10
diff -u -b -w -r1.10 fficonfig.h.in
--- fficonfig.h.in	19 Dec 2008 16:13:45 -0000	1.10
+++ fficonfig.h.in	10 Jun 2009 10:29:30 -0000
@@ -1,5 +1,8 @@
 /* fficonfig.h.in.  Generated from configure.ac by autoheader.  */
 
+/* Define if building universal (internal helper macro) */
+#undef AC_APPLE_UNIVERSAL_BUILD
+
 /* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
    systems. This function is required for `alloca.c' support on those systems.
    */
@@ -142,9 +145,17 @@
 /* Version number of package */
 #undef VERSION
 
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
 #undef WORDS_BIGENDIAN
+# endif
+#endif
 
 
 #ifdef HAVE_HIDDEN_VISIBILITY_ATTRIBUTE
Index: ltcf-c.sh
===================================================================
RCS file: /cvs/libffi/libffi/ltcf-c.sh,v
retrieving revision 1.1
diff -u -b -w -r1.1 ltcf-c.sh
--- ltcf-c.sh	29 Jan 2008 12:30:10 -0000	1.1
+++ ltcf-c.sh	10 Jun 2009 10:29:30 -0000
@@ -376,7 +376,7 @@
     old_archive_from_new_cmds='true'
     # FIXME: Should let the user specify the lib program.
     old_archive_cmds='lib /OUT:$oldlib$oldobjs$old_deplibs'
-    fix_srcfile_path='`cygpath -w "$srcfile"`'
+    fix_srcfile_path='\`cygpath -w \"\$srcfile\"\`'
     ;;
 
   darwin* | rhapsody*)
Index: doc/libffi.info
===================================================================
RCS file: /cvs/libffi/libffi/doc/libffi.info,v
retrieving revision 1.3
diff -u -b -w -r1.3 libffi.info
--- doc/libffi.info	19 Dec 2008 15:47:44 -0000	1.3
+++ doc/libffi.info	10 Jun 2009 10:29:30 -0000
@@ -1,4 +1,4 @@
-This is doc/libffi.info, produced by makeinfo version 4.12 from
+This is doc/libffi.info, produced by makeinfo version 4.13 from
 ./doc/libffi.texi.
 
 This manual is for Libffi, a portable foreign-function interface
@@ -510,8 +510,8 @@
 * ffi_type_ushort:                       Primitive Types.      (line 53)
 * ffi_type_void:                         Primitive Types.      (line 10)
 * Foreign Function Interface:            Introduction.         (line 31)
-* void <1>:                              The Closure API.      (line 20)
-* void:                                  The Basics.           (line 43)
+* void <1>:                              The Basics.           (line 43)
+* void:                                  The Closure API.      (line 27)
 
 
 
Index: doc/stamp-vti
===================================================================
RCS file: /cvs/libffi/libffi/doc/stamp-vti,v
retrieving revision 1.16
diff -u -b -w -r1.16 stamp-vti
--- doc/stamp-vti	19 Dec 2008 16:13:45 -0000	1.16
+++ doc/stamp-vti	10 Jun 2009 10:29:30 -0000
@@ -1,4 +1,4 @@
-@set UPDATED 14 February 2008
-@set UPDATED-MONTH February 2008
+@set UPDATED 16 December 2008
+@set UPDATED-MONTH December 2008
 @set EDITION 3.0.8
 @set VERSION 3.0.8
Index: doc/version.texi
===================================================================
RCS file: /cvs/libffi/libffi/doc/version.texi,v
retrieving revision 1.17
diff -u -b -w -r1.17 version.texi
--- doc/version.texi	19 Dec 2008 16:13:45 -0000	1.17
+++ doc/version.texi	10 Jun 2009 10:29:30 -0000
@@ -1,4 +1,4 @@
-@set UPDATED 14 February 2008
-@set UPDATED-MONTH February 2008
+@set UPDATED 16 December 2008
+@set UPDATED-MONTH December 2008
 @set EDITION 3.0.8
 @set VERSION 3.0.8
Index: include/Makefile.in
===================================================================
RCS file: /cvs/libffi/libffi/include/Makefile.in,v
retrieving revision 1.20
diff -u -b -w -r1.20 Makefile.in
--- include/Makefile.in	19 Dec 2008 15:47:44 -0000	1.20
+++ include/Makefile.in	10 Jun 2009 10:29:30 -0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -194,8 +194,8 @@
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
 	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
 	      exit 1;; \
 	  esac; \
 	done; \
@@ -250,7 +250,7 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
 	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	mkid -fID $$unique
 tags: TAGS
Index: include/ffi.h.in
===================================================================
RCS file: /cvs/libffi/libffi/include/ffi.h.in,v
retrieving revision 1.12
diff -u -b -w -r1.12 ffi.h.in
--- include/ffi.h.in	3 Apr 2008 18:57:34 -0000	1.12
+++ include/ffi.h.in	10 Jun 2009 10:29:30 -0000
@@ -67,6 +67,10 @@
 
 #ifndef LIBFFI_ASM
 
+#ifdef _MSC_VER
+#define __attribute__(X)
+#endif
+
 #include <stddef.h>
 #include <limits.h>
 
Index: include/ffi_common.h
===================================================================
RCS file: /cvs/libffi/libffi/include/ffi_common.h,v
retrieving revision 1.7
diff -u -b -w -r1.7 ffi_common.h
--- include/ffi_common.h	29 Jan 2008 15:15:17 -0000	1.7
+++ include/ffi_common.h	10 Jun 2009 10:29:30 -0000
@@ -18,7 +18,10 @@
 /* Do not move this. Some versions of AIX are very picky about where
    this is positioned. */
 #ifdef __GNUC__
+/* mingw64 defines this already in malloc.h. */
+#ifndef alloca
 # define alloca __builtin_alloca
+#endif
 # define MAYBE_UNUSED __attribute__((__unused__))
 #else
 # define MAYBE_UNUSED
@@ -29,11 +32,15 @@
  #pragma alloca
 #  else
 #   ifndef alloca /* predefined by HP cc +Olibcalls */
+#    ifdef _MSC_VER
+#     define alloca _alloca
+#    else
 char *alloca ();
 #   endif
 #  endif
 # endif
 #endif
+#endif
 
 /* Check for the existence of memcpy. */
 #if STDC_HEADERS
@@ -77,6 +84,16 @@
 } extended_cif;
 
 /* Terse sized type definitions.  */
+#ifdef _MSC_VER
+typedef unsigned char UINT8;
+typedef signed char   SINT8;
+typedef unsigned short UINT16;
+typedef signed short   SINT16;
+typedef unsigned int UINT32;
+typedef signed int   SINT32;
+typedef unsigned __int64 UINT64;
+typedef signed __int64   SINT64;
+#else
 typedef unsigned int UINT8  __attribute__((__mode__(__QI__)));
 typedef signed int   SINT8  __attribute__((__mode__(__QI__)));
 typedef unsigned int UINT16 __attribute__((__mode__(__HI__)));
@@ -85,6 +102,7 @@
 typedef signed int   SINT32 __attribute__((__mode__(__SI__)));
 typedef unsigned int UINT64 __attribute__((__mode__(__DI__)));
 typedef signed int   SINT64 __attribute__((__mode__(__DI__)));
+#endif
 
 typedef float FLOAT32;
 
Index: man/Makefile.in
===================================================================
RCS file: /cvs/libffi/libffi/man/Makefile.in,v
retrieving revision 1.3
diff -u -b -w -r1.3 Makefile.in
--- man/Makefile.in	19 Dec 2008 15:47:44 -0000	1.3
+++ man/Makefile.in	10 Jun 2009 10:29:30 -0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -183,8 +183,8 @@
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
 	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
 	      exit 1;; \
 	  esac; \
 	done; \
@@ -225,8 +225,8 @@
 	  esac; \
 	done; \
 	for i in $$list; do \
-	  if test -f $(srcdir)/$$i; then file=$(srcdir)/$$i; \
-	  else file=$$i; fi; \
+	  if test -f $$i; then file=$$i; \
+	  else file=$(srcdir)/$$i; fi; \
 	  ext=`echo $$i | sed -e 's/^.*\\.//'`; \
 	  case "$$ext" in \
 	    3*) ;; \
Index: man/ffi_call.3
===================================================================
RCS file: /cvs/libffi/libffi/man/ffi_call.3,v
retrieving revision 1.2
diff -u -b -w -r1.2 ffi_call.3
--- man/ffi_call.3	15 Feb 2008 15:30:26 -0000	1.2
+++ man/ffi_call.3	10 Jun 2009 10:29:30 -0000
@@ -34,8 +34,8 @@
 .Nm ffi_call .
 .Pp
 .Fa rvalue
-must point to storage that is sizeof(long) or larger. For smaller
-return value sizes, the
+must point to storage that is sizeof(ffi_arg) or larger for non-floating point
+types. For smaller-sized return value types, the
 .Nm ffi_arg
 or
 .Nm ffi_sarg
Index: src/closures.c
===================================================================
RCS file: /cvs/libffi/libffi/src/closures.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 closures.c
--- src/closures.c	15 Feb 2008 01:24:05 -0000	1.2
+++ src/closures.c	10 Jun 2009 10:29:30 -0000
@@ -42,6 +42,13 @@
    locations in the virtual memory space, one location writable and
    another executable.  */
 #  define FFI_MMAP_EXEC_WRIT 1
+#  define HAVE_MNTENT 1
+# endif
+# if defined(X86_WIN32) || defined(X86_WIN64)
+/* Windows systems may have Data Execution Protection (DEP) enabled, 
+   which requires the use of VirtualMalloc/VirtualFree to alloc/free
+   executable memory. */
+#  define FFI_MMAP_EXEC_WRIT 1
 # endif
 #endif
 
@@ -60,7 +67,11 @@
 
 #define USE_LOCKS 1
 #define USE_DL_PREFIX 1
+#ifdef __GNUC__
+#ifndef USE_BUILTIN_FFS
 #define USE_BUILTIN_FFS 1
+#endif
+#endif
 
 /* We need to use mmap, not sbrk.  */
 #define HAVE_MORECORE 0
@@ -90,10 +101,15 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#endif
 #include <string.h>
 #include <stdio.h>
+#if !defined(X86_WIN32) && !defined(X86_WIN64)
+#ifdef HAVE_MNTENT
 #include <mntent.h>
+#endif /* HAVE_MNTENT */
 #include <sys/param.h>
 #include <pthread.h>
 
@@ -150,6 +166,7 @@
 #define is_selinux_enabled() 0
 
 #endif
+#endif /* !defined(X86_WIN32) && !defined(X86_WIN64) */
 
 /* Declare all functions defined in dlmalloc.c as static.  */
 static void *dlmalloc(size_t);
@@ -168,9 +185,11 @@
 static size_t dlmalloc_usable_size(void*) MAYBE_UNUSED;
 static void dlmalloc_stats(void) MAYBE_UNUSED;
 
+#if !defined(X86_WIN32) && !defined(X86_WIN64)
 /* Use these for mmap and munmap within dlmalloc.c.  */
 static void *dlmmap(void *, size_t, int, int, int, off_t);
 static int dlmunmap(void *, size_t);
+#endif /* !defined(X86_WIN32) && !defined(X86_WIN64) */
 
 #define mmap dlmmap
 #define munmap dlmunmap
@@ -180,6 +199,8 @@
 #undef mmap
 #undef munmap
 
+#if !defined(X86_WIN32) && !defined(X86_WIN64)
+
 /* A mutex used to synchronize access to *exec* variables in this file.  */
 static pthread_mutex_t open_temp_exec_file_mutex = PTHREAD_MUTEX_INITIALIZER;
 
@@ -232,6 +253,7 @@
   return open_temp_exec_file_dir (value);
 }
 
+#ifdef HAVE_MNTENT
 /* Open a temporary file in an executable and writable mount point
    listed in the mounts file.  Subsequent calls with the same mounts
    keep searching for mount points in the same file.  Providing NULL
@@ -278,6 +300,7 @@
 	return fd;
     }
 }
+#endif /* HAVE_MNTENT */
 
 /* Instructions to look for a location to hold a temporary file that
    can be mapped in for execution.  */
@@ -292,8 +315,10 @@
   { open_temp_exec_file_dir, "/var/tmp", 0 },
   { open_temp_exec_file_dir, "/dev/shm", 0 },
   { open_temp_exec_file_env, "HOME", 0 },
+#ifdef HAVE_MNTENT
   { open_temp_exec_file_mnt, "/etc/mtab", 1 },
   { open_temp_exec_file_mnt, "/proc/mounts", 1 },
+#endif /* HAVE_MNTENT */
 };
 
 /* Current index into open_temp_exec_file_opts.  */
@@ -489,6 +514,8 @@
 }
 #endif
 
+#endif /* !defined(X86_WIN32) && !defined(X86_WIN64) */
+
 /* Allocate a chunk of memory with the given size.  Returns a pointer
    to the writable address, and sets *CODE to the executable
    corresponding virtual address.  */
Index: src/dlmalloc.c
===================================================================
RCS file: /cvs/libffi/libffi/src/dlmalloc.c,v
retrieving revision 1.1
diff -u -b -w -r1.1 dlmalloc.c
--- src/dlmalloc.c	29 Jan 2008 15:16:43 -0000	1.1
+++ src/dlmalloc.c	10 Jun 2009 10:29:31 -0000
@@ -1140,9 +1140,9 @@
 
 /*------------------------------ internal #includes ---------------------- */
 
-#ifdef WIN32
+#ifdef _MSC_VER
 #pragma warning( disable : 4146 ) /* no "unsigned" warnings */
-#endif /* WIN32 */
+#endif /* _MSC_VER */
 
 #include <stdio.h>       /* for printing in malloc_stats */
 
@@ -1315,14 +1315,14 @@
 
 /* Win32 MMAP via VirtualAlloc */
 static void* win32mmap(size_t size) {
-  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
   return (ptr != 0)? ptr: MFAIL;
 }
 
 /* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
 static void* win32direct_mmap(size_t size) {
   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
-                           PAGE_READWRITE);
+                           PAGE_EXECUTE_READWRITE);
   return (ptr != 0)? ptr: MFAIL;
 }
 
Index: src/prep_cif.c
===================================================================
RCS file: /cvs/libffi/libffi/src/prep_cif.c,v
retrieving revision 1.7
diff -u -b -w -r1.7 prep_cif.c
--- src/prep_cif.c	15 Feb 2008 01:24:05 -0000	1.7
+++ src/prep_cif.c	10 Jun 2009 10:29:31 -0000
@@ -39,9 +39,11 @@
 
   FFI_ASSERT(arg != NULL);
 
-  FFI_ASSERT(arg->elements != NULL);
   FFI_ASSERT(arg->size == 0);
-  FFI_ASSERT(arg->alignment == 0);
+
+  if (arg->elements == NULL || arg->alignment != 0) {
+    return FFI_BAD_TYPEDEF;
+  }
 
   ptr = &(arg->elements[0]);
 
@@ -93,7 +95,12 @@
   ffi_type **ptr;
 
   FFI_ASSERT(cif != NULL);
-  FFI_ASSERT((abi > FFI_FIRST_ABI) && (abi <= FFI_DEFAULT_ABI));
+  /* FIXME: most targets have a broken definition of FFI_LAST_ABI */
+  /*
+  if (abi < FFI_FIRST_ABI || abi > FFI_LAST_ABI) {
+    return FFI_BAD_ABI;
+  }
+  */
 
   cif->abi = abi;
   cif->arg_types = atypes;
Index: src/x86/ffi.c
===================================================================
RCS file: /cvs/libffi/libffi/src/x86/ffi.c,v
retrieving revision 1.15
diff -u -b -w -r1.15 ffi.c
--- src/x86/ffi.c	3 Apr 2008 18:57:34 -0000	1.15
+++ src/x86/ffi.c	10 Jun 2009 10:29:31 -0000
@@ -28,7 +28,11 @@
    DEALINGS IN THE SOFTWARE.
    ----------------------------------------------------------------------- */
 
-#ifndef __x86_64__
+#if !defined(__x86_64__) || defined(_WIN64)
+
+#ifdef _WIN64
+#include <windows.h>
+#endif
 
 #include <ffi.h>
 #include <ffi_common.h>
@@ -47,10 +51,15 @@
 
   argp = stack;
 
-  if (ecif->cif->flags == FFI_TYPE_STRUCT)
+  if (ecif->cif->flags == FFI_TYPE_STRUCT
+#ifdef X86_WIN64
+      && (ecif->cif->rtype->size != 1 && ecif->cif->rtype->size != 2
+          && ecif->cif->rtype->size != 4 && ecif->cif->rtype->size != 8)
+#endif
+      )
     {
       *(void **) argp = ecif->rvalue;
-      argp += 4;
+      argp += sizeof(void*);
     }
 
   p_argv = ecif->avalue;
@@ -62,41 +71,59 @@
       size_t z;
 
       /* Align if necessary */
-      if ((sizeof(int) - 1) & (unsigned) argp)
-	argp = (char *) ALIGN(argp, sizeof(int));
+      if ((sizeof(void*) - 1) & (size_t) argp)
+        argp = (char *) ALIGN(argp, sizeof(void*));
 
       z = (*p_arg)->size;
-      if (z < sizeof(int))
+#ifdef X86_WIN64
+      if (z > sizeof(ffi_arg)
+          || ((*p_arg)->type == FFI_TYPE_STRUCT
+              && (z != 1 && z != 2 && z != 4 && z != 8))
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+          || ((*p_arg)->type == FFI_TYPE_LONGDOUBLE)
+#endif
+          )
+        {
+          z = sizeof(ffi_arg);
+          *(void **)argp = *p_argv;
+        }
+      else if ((*p_arg)->type == FFI_TYPE_FLOAT)
 	{
-	  z = sizeof(int);
+          memcpy(argp, *p_argv, z);
+        }
+      else
+#endif
+      if (z < sizeof(ffi_arg))
+        {
+          z = sizeof(ffi_arg);
 	  switch ((*p_arg)->type)
 	    {
 	    case FFI_TYPE_SINT8:
-	      *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT8 *)(* p_argv);
 	      break;
 
 	    case FFI_TYPE_UINT8:
-	      *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+              *(ffi_arg *) argp = (ffi_arg)*(UINT8 *)(* p_argv);
 	      break;
 
 	    case FFI_TYPE_SINT16:
-	      *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT16 *)(* p_argv);
 	      break;
 
 	    case FFI_TYPE_UINT16:
-	      *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+              *(ffi_arg *) argp = (ffi_arg)*(UINT16 *)(* p_argv);
 	      break;
 
 	    case FFI_TYPE_SINT32:
-	      *(signed int *) argp = (signed int)*(SINT32 *)(* p_argv);
+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT32 *)(* p_argv);
 	      break;
 
 	    case FFI_TYPE_UINT32:
-	      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+              *(ffi_arg *) argp = (ffi_arg)*(UINT32 *)(* p_argv);
 	      break;
 
 	    case FFI_TYPE_STRUCT:
-	      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+              *(ffi_arg *) argp = *(ffi_arg *)(* p_argv);
 	      break;
 
 	    default:
@@ -108,7 +135,11 @@
 	  memcpy(argp, *p_argv, z);
 	}
       p_argv++;
+#ifdef X86_WIN64
+      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
+#else
       argp += z;
+#endif
     }
   
   return;
@@ -124,21 +155,32 @@
 #ifdef X86
     case FFI_TYPE_STRUCT:
 #endif
-#if defined(X86) || defined(X86_DARWIN)
+#if defined(X86) || defined(X86_DARWIN) || defined(X86_WIN64)
     case FFI_TYPE_UINT8:
     case FFI_TYPE_UINT16:
     case FFI_TYPE_SINT8:
     case FFI_TYPE_SINT16:
 #endif
+#ifdef X86_WIN64
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+#endif
 
     case FFI_TYPE_SINT64:
     case FFI_TYPE_FLOAT:
     case FFI_TYPE_DOUBLE:
+#ifndef X86_WIN64
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
     case FFI_TYPE_LONGDOUBLE:
+#endif
+#endif
       cif->flags = (unsigned) cif->rtype->type;
       break;
 
     case FFI_TYPE_UINT64:
+#ifdef X86_WIN64
+    case FFI_TYPE_POINTER:
+#endif
       cif->flags = FFI_TYPE_SINT64;
       break;
 
@@ -154,7 +196,11 @@
         }
       else if (cif->rtype->size == 4)
         {
+#ifdef X86_WIN64
+          cif->flags = FFI_TYPE_SMALL_STRUCT_4B;
+#else
           cif->flags = FFI_TYPE_INT; /* same as int type */
+#endif
         }
       else if (cif->rtype->size == 8)
         {
@@ -163,12 +209,23 @@
       else
         {
           cif->flags = FFI_TYPE_STRUCT;
+#ifdef X86_WIN64
+          // allocate space for return value pointer
+          cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);
+#endif
         }
       break;
 #endif
 
     default:
+#ifdef X86_WIN64
+      cif->flags = FFI_TYPE_SINT64;
+      break;
+    case FFI_TYPE_INT:
+      cif->flags = FFI_TYPE_SINT32;
+#else
       cif->flags = FFI_TYPE_INT;
+#endif
       break;
     }
 
@@ -176,6 +233,22 @@
   cif->bytes = (cif->bytes + 15) & ~0xF;
 #endif
 
+#ifdef X86_WIN64
+  {
+    unsigned int i;
+    ffi_type **ptr;
+
+    for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+      {
+        if (((*ptr)->alignment - 1) & cif->bytes)
+          cif->bytes = ALIGN(cif->bytes, (*ptr)->alignment);
+        cif->bytes += ALIGN((*ptr)->size, FFI_SIZEOF_ARG);
+      }
+  }
+  // ensure space for storing four registers
+  cif->bytes += 4 * sizeof(ffi_arg);
+#endif
+
   return FFI_OK;
 }
 
@@ -187,6 +260,11 @@
 			  unsigned, unsigned, unsigned *, void (*fn)(void));
 
 #endif /* X86_WIN32 */
+#ifdef X86_WIN64
+extern int
+ffi_call_win64(void (*)(char *, extended_cif *), extended_cif *,
+               unsigned, unsigned, unsigned *, void (*fn)(void));
+#endif
 
 void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
 {
@@ -198,17 +276,52 @@
   /* If the return value is a struct and we don't have a return	*/
   /* value address then we need to make one		        */
 
-  if ((rvalue == NULL) && 
-      (cif->flags == FFI_TYPE_STRUCT))
+#ifdef X86_WIN64
+  if (rvalue == NULL
+      && cif->flags == FFI_TYPE_STRUCT
+      && cif->rtype->size != 1 && cif->rtype->size != 2
+      && cif->rtype->size != 4 && cif->rtype->size != 8)
+    {
+      ecif.rvalue = alloca((cif->rtype->size + 0xF) & ~0xF);
+    }
+#else
+  if (rvalue == NULL
+      && cif->flags == FFI_TYPE_STRUCT)
     {
       ecif.rvalue = alloca(cif->rtype->size);
     }
+#endif
   else
     ecif.rvalue = rvalue;
     
   
   switch (cif->abi) 
     {
+#ifdef X86_WIN64
+    case FFI_WIN64:
+      {
+        // Make copies of all struct arguments
+        // NOTE: not sure if responsibility should be here or in caller
+        unsigned int i;
+        for (i=0; i < cif->nargs;i++) {
+          size_t size = cif->arg_types[i]->size;
+          if ((cif->arg_types[i]->type == FFI_TYPE_STRUCT
+               && (size != 1 && size != 2 && size != 4 && size != 8))
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+              || cif->arg_types[i]->type == FFI_TYPE_LONGDOUBLE
+#endif
+              )
+            {
+              void *local = alloca(size);
+              memcpy(local, avalue[i], size);
+              avalue[i] = local;
+            }
+        }
+        ffi_call_win64(ffi_prep_args, &ecif, cif->bytes,
+                       cif->flags, ecif.rvalue, fn);
+      }
+      break;
+#else
     case FFI_SYSV:
       ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
 		    fn);
@@ -219,6 +332,7 @@
 		       ecif.rvalue, fn);
       break;
 #endif /* X86_WIN32 */
+#endif /* X86_WIN64 */
     default:
       FFI_ASSERT(0);
       break;
@@ -240,9 +354,42 @@
 void FFI_HIDDEN ffi_closure_STDCALL (ffi_closure *)
      __attribute__ ((regparm(1)));
 #endif
+#ifdef X86_WIN64
+void FFI_HIDDEN ffi_closure_win64 (ffi_closure *);
+#endif
 
 /* This function is jumped to by the trampoline */
 
+#ifdef X86_WIN64
+void * FFI_HIDDEN
+ffi_closure_win64_inner (ffi_closure *closure, void *args) {
+  ffi_cif       *cif;
+  void         **arg_area;
+  void          *result;
+  void          *resp = &result;
+
+  cif         = closure->cif;
+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  
+
+  /* this call will initialize ARG_AREA, such that each
+   * element in that array points to the corresponding 
+   * value on the stack; and if the function returns
+   * a structure, it will change RESP to point to the
+   * structure return address.  */
+
+  ffi_prep_incoming_args_SYSV(args, &resp, arg_area, cif);
+  
+  (closure->fun) (cif, resp, arg_area, closure->user_data);
+
+  /* The result is returned in rax.  This does the right thing for
+     result types except for floats; we have to 'mov xmm0, rax' in the
+     caller to correct this.
+     TODO: structure sizes of 3 5 6 7 are returned by reference, too!!!
+  */
+  return cif->rtype->size > sizeof(void *) ? resp : *(void **)resp;
+}
+
+#else
 unsigned int FFI_HIDDEN
 ffi_closure_SYSV_inner (closure, respp, args)
      ffi_closure *closure;
@@ -259,7 +406,7 @@
   /* this call will initialize ARG_AREA, such that each
    * element in that array points to the corresponding 
    * value on the stack; and if the function returns
-   * a structure, it will re-set RESP to point to the
+   * a structure, it will change RESP to point to the
    * structure return address.  */
 
   ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif);
@@ -268,6 +415,7 @@
 
   return cif->flags;
 }
+#endif /* !X86_WIN64 */
 
 static void
 ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,
@@ -280,10 +428,20 @@
 
   argp = stack;
 
+#ifdef X86_WIN64
+  if (cif->rtype->size > sizeof(ffi_arg)
+      || (cif->flags == FFI_TYPE_STRUCT
+          && (cif->rtype->size != 1 && cif->rtype->size != 2
+              && cif->rtype->size != 4 && cif->rtype->size != 8))) {
+    *rvalue = *(void **) argp;
+    argp += sizeof(void *);
+  }
+#else
   if ( cif->flags == FFI_TYPE_STRUCT ) {
     *rvalue = *(void **) argp;
-    argp += 4;
+    argp += sizeof(void *);
   }
+#endif
 
   p_argv = avalue;
 
@@ -292,23 +450,58 @@
       size_t z;
 
       /* Align if necessary */
-      if ((sizeof(int) - 1) & (unsigned) argp) {
-	argp = (char *) ALIGN(argp, sizeof(int));
+      if ((sizeof(void*) - 1) & (size_t) argp) {
+        argp = (char *) ALIGN(argp, sizeof(void*));
       }
 
+#ifdef X86_WIN64
+      if ((*p_arg)->size > sizeof(ffi_arg)
+          || ((*p_arg)->type == FFI_TYPE_STRUCT
+              && ((*p_arg)->size != 1 && (*p_arg)->size != 2
+                  && (*p_arg)->size != 4 && (*p_arg)->size != 8)))
+        {
+          z = sizeof(void *);
+          *p_argv = *(void **)argp;
+        }
+      else
+#endif
+        {
       z = (*p_arg)->size;
 
       /* because we're little endian, this is what it turns into.   */
 
       *p_argv = (void*) argp;
+        }
 
       p_argv++;
+#ifdef X86_WIN64
+      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
+#else
       argp += z;
+#endif
     }
   
   return;
 }
 
+#define FFI_INIT_TRAMPOLINE_WIN64(TRAMP,FUN,CTX,MASK) \
+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \
+   void*  __fun = (void*)(FUN); \
+   void*  __ctx = (void*)(CTX); \
+   *(unsigned char*) &__tramp[0] = 0x41; \
+   *(unsigned char*) &__tramp[1] = 0xbb; \
+   *(unsigned int*) &__tramp[2] = MASK; /* mov $mask, %r11 */ \
+   *(unsigned char*) &__tramp[6] = 0x48; \
+   *(unsigned char*) &__tramp[7] = 0xb8; \
+   *(void**) &__tramp[8] = __ctx; /* mov __ctx, %rax */ \
+   *(unsigned char *)  &__tramp[16] = 0x49; \
+   *(unsigned char *)  &__tramp[17] = 0xba; \
+   *(void**) &__tramp[18] = __fun; /* mov __fun, %r10 */ \
+   *(unsigned char *)  &__tramp[26] = 0x41; \
+   *(unsigned char *)  &__tramp[27] = 0xff; \
+   *(unsigned char *)  &__tramp[28] = 0xe2; /* jmp %r10 */ \
+ }
+
 /* How to make a trampoline.  Derived from gcc/config/i386/i386.c. */
 
 #define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \
@@ -345,6 +538,18 @@
 		      void *user_data,
 		      void *codeloc)
 {
+#ifdef X86_WIN64
+#define ISFLOAT(IDX) (cif->arg_types[IDX]->type == FFI_TYPE_FLOAT || cif->arg_types[IDX]->type == FFI_TYPE_DOUBLE)
+#define FLAG(IDX) (cif->nargs>(IDX)&&ISFLOAT(IDX)?(1<<(IDX)):0)
+  if (cif->abi == FFI_WIN64) 
+    {
+      int mask = FLAG(0)|FLAG(1)|FLAG(2)|FLAG(3);
+      FFI_INIT_TRAMPOLINE_WIN64 (&closure->tramp[0],
+                                 &ffi_closure_win64,
+                                 codeloc, mask);
+      /* make sure we can execute here */
+    }
+#else
   if (cif->abi == FFI_SYSV)
     {
       FFI_INIT_TRAMPOLINE (&closure->tramp[0],
@@ -358,7 +563,8 @@
                                    &ffi_closure_STDCALL,
                                    (void*)codeloc, cif->bytes);
     }
-#endif
+#endif /* X86_WIN32 */
+#endif /* !X86_WIN64 */
   else
     {
       return FFI_BAD_ABI;
@@ -472,4 +678,5 @@
 
 #endif
 
-#endif /* __x86_64__  */
+#endif /* !__x86_64__  || X86_WIN64 */
+
Index: src/x86/ffi64.c
===================================================================
RCS file: /cvs/libffi/libffi/src/x86/ffi64.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 ffi64.c
--- src/x86/ffi64.c	26 Feb 2008 17:34:36 -0000	1.4
+++ src/x86/ffi64.c	10 Jun 2009 10:29:31 -0000
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   ffi.c - Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>
+   ffi64.c - Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>
            Copyright (c) 2008  Red Hat, Inc.
    
    x86-64 Foreign Function Interface 
Index: src/x86/ffitarget.h
===================================================================
RCS file: /cvs/libffi/libffi/src/x86/ffitarget.h,v
retrieving revision 1.5
diff -u -b -w -r1.5 ffitarget.h
--- src/x86/ffitarget.h	15 Feb 2008 01:24:06 -0000	1.5
+++ src/x86/ffitarget.h	10 Jun 2009 10:29:31 -0000
@@ -36,11 +36,26 @@
 #define X86
 #endif
 
+#ifdef X86_WIN64
+#define FFI_SIZEOF_ARG 8
+#define USE_BUILTIN_FFS 0 // not yet implemented in mingw-64 
+#endif
+
 /* ---- Generic type definitions ----------------------------------------- */
 
 #ifndef LIBFFI_ASM
+#ifdef X86_WIN64
+#ifdef _MSC_VER
+typedef unsigned __int64       ffi_arg;
+typedef __int64                ffi_sarg;
+#else
+typedef unsigned long long     ffi_arg;
+typedef long long              ffi_sarg;
+#endif
+#else
 typedef unsigned long          ffi_arg;
 typedef signed long            ffi_sarg;
+#endif
 
 typedef enum ffi_abi {
   FFI_FIRST_ABI = 0,
@@ -53,6 +68,11 @@
   FFI_DEFAULT_ABI = FFI_SYSV,
 #endif
 
+#ifdef X86_WIN64
+  FFI_WIN64,
+  FFI_DEFAULT_ABI = FFI_WIN64,
+#else
+
   /* ---- Intel x86 and AMD x86-64 - */
 #if !defined(X86_WIN32) && (defined(__i386__) || defined(__x86_64__))
   FFI_SYSV,
@@ -63,6 +83,7 @@
   FFI_DEFAULT_ABI = FFI_UNIX64,
 #endif
 #endif
+#endif /* X86_WIN64 */
 
   FFI_LAST_ABI = FFI_DEFAULT_ABI + 1
 } ffi_abi;
@@ -73,6 +94,7 @@
 #define FFI_CLOSURES 1
 #define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)
 #define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)
+#define FFI_TYPE_SMALL_STRUCT_4B (FFI_TYPE_LAST + 3)
 
 #if defined (X86_64) || (defined (__x86_64__) && defined (X86_DARWIN))
 #define FFI_TRAMPOLINE_SIZE 24
@@ -81,10 +103,18 @@
 #ifdef X86_WIN32
 #define FFI_TRAMPOLINE_SIZE 13
 #else
+#ifdef X86_WIN64
+#define FFI_TRAMPOLINE_SIZE 29
+#define FFI_NATIVE_RAW_API 0
+#define FFI_NO_RAW_API 1
+#else
 #define FFI_TRAMPOLINE_SIZE 10
 #endif
+#endif
+#ifndef X86_WIN64
 #define FFI_NATIVE_RAW_API 1	/* x86 has native raw api support */
 #endif
+#endif
 
 #endif
 
Index: src/x86/win64.S
===================================================================
RCS file: src/x86/win64.S
diff -N src/x86/win64.S
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/x86/win64.S	10 Jun 2009 10:29:31 -0000
@@ -0,0 +1,462 @@
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+	
+/* Constants for ffi_call_win64 */	
+#define STACK 0
+#define PREP_ARGS_FN 32
+#define ECIF 40
+#define CIF_BYTES 48
+#define CIF_FLAGS 56
+#define RVALUE 64
+#define FN 72
+
+/* ffi_call_win64 (void (*prep_args_fn)(char *, extended_cif *),
+                   extended_cif *ecif, unsigned bytes, unsigned flags,
+                   unsigned *rvalue, void (*fn)());
+ */
+
+#ifdef _MSC_VER
+PUBLIC	ffi_call_win64
+
+EXTRN	__chkstk:NEAR
+EXTRN	ffi_closure_win64_inner:NEAR
+
+_TEXT	SEGMENT
+
+;;; ffi_closure_win64 will be called with these registers set:
+;;;    rax points to 'closure'
+;;;    r11 contains a bit mask that specifies which of the
+;;;    first four parameters are float or double
+;;;
+;;; It must move the parameters passed in registers to their stack location,
+;;; call ffi_closure_win64_inner for the actual work, then return the result.
+;;; 
+ffi_closure_win64 PROC FRAME
+	;; copy register arguments onto stack
+	test	r11, 1
+	jne	first_is_float	
+	mov	QWORD PTR [rsp+8], rcx
+	jmp	second
+first_is_float:
+	movlpd	QWORD PTR [rsp+8], xmm0
+
+second:
+	test	r11, 2
+	jne	second_is_float	
+	mov	QWORD PTR [rsp+16], rdx
+	jmp	third
+second_is_float:
+	movlpd	QWORD PTR [rsp+16], xmm1
+
+third:
+	test	r11, 4
+	jne	third_is_float	
+	mov	QWORD PTR [rsp+24], r8
+	jmp	fourth
+third_is_float:
+	movlpd	QWORD PTR [rsp+24], xmm2
+
+fourth:
+	test	r11, 8
+	jne	fourth_is_float	
+	mov	QWORD PTR [rsp+32], r9
+	jmp	done
+fourth_is_float:
+	movlpd	QWORD PTR [rsp+32], xmm3
+
+done:
+        .ALLOCSTACK 40
+	sub	rsp, 40
+        .ENDPROLOG
+	mov	rcx, rax	; context is first parameter
+	mov	rdx, rsp	; stack is second parameter
+	add	rdx, 48		; point to start of arguments
+	mov	rax, ffi_closure_win64_inner
+	call	rax		; call the real closure function
+	add	rsp, 40
+	movd	xmm0, rax	; If the closure returned a float,
+                                ; ffi_closure_win64_inner wrote it to rax
+	ret	0
+ffi_closure_win64 ENDP
+
+ffi_call_win64 PROC FRAME
+        ;; copy registers onto stack
+	mov	QWORD PTR [rsp+32], r9
+	mov	QWORD PTR [rsp+24], r8
+	mov	QWORD PTR [rsp+16], rdx
+	mov	QWORD PTR [rsp+8], rcx
+        .PUSHREG rbp
+	push	rbp
+        .ALLOCSTACK 48
+	sub	rsp, 48					; 00000030H
+        .SETFRAME rbp, 32
+	lea	rbp, QWORD PTR [rsp+32]
+        .ENDPROLOG
+
+	mov	eax, DWORD PTR CIF_BYTES[rbp]
+	add	rax, 15
+	and	rax, -16
+	call	__chkstk
+	sub	rsp, rax
+	lea	rax, QWORD PTR [rsp+32]
+	mov	QWORD PTR STACK[rbp], rax
+
+	mov	rdx, QWORD PTR ECIF[rbp]
+	mov	rcx, QWORD PTR STACK[rbp]
+	call	QWORD PTR PREP_ARGS_FN[rbp]
+
+	mov	rsp, QWORD PTR STACK[rbp]
+
+	movlpd	xmm3, QWORD PTR [rsp+24]
+	movd	r9, xmm3
+
+	movlpd	xmm2, QWORD PTR [rsp+16]
+	movd	r8, xmm2
+
+	movlpd	xmm1, QWORD PTR [rsp+8]
+	movd	rdx, xmm1
+
+	movlpd	xmm0, QWORD PTR [rsp]
+	movd	rcx, xmm0
+
+	call	QWORD PTR FN[rbp]
+ret_struct4b$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_4B
+ 	jne	ret_struct2b$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	mov	DWORD PTR [rcx], eax
+	jmp	ret_void$
+
+ret_struct2b$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_2B
+ 	jne	ret_struct1b$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	mov	WORD PTR [rcx], ax
+	jmp	ret_void$
+
+ret_struct1b$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_1B
+ 	jne	ret_uint8$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	mov	BYTE PTR [rcx], al
+	jmp	ret_void$
+
+ret_uint8$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT8
+ 	jne	ret_sint8$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	movzx   rax, al
+	mov	QWORD PTR [rcx], rax
+	jmp	ret_void$
+
+ret_sint8$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT8
+ 	jne	ret_uint16$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	movsx   rax, al
+	mov	QWORD PTR [rcx], rax
+	jmp	ret_void$
+
+ret_uint16$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT16
+ 	jne	ret_sint16$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	movzx   rax, ax
+	mov	QWORD PTR [rcx], rax
+	jmp	SHORT ret_void$
+
+ret_sint16$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT16
+ 	jne	ret_uint32$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	movsx   rax, ax
+	mov	QWORD PTR [rcx], rax
+	jmp	SHORT ret_void$
+
+ret_uint32$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT32
+ 	jne	ret_sint32$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	mov     eax, eax
+	mov	QWORD PTR [rcx], rax
+	jmp	SHORT ret_void$
+
+ret_sint32$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT32
+ 	jne	ret_float$
+
+	mov	rcx, QWORD PTR RVALUE[rbp]
+	cdqe
+	mov	QWORD PTR [rcx], rax
+	jmp	SHORT ret_void$
+
+ret_float$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_FLOAT
+ 	jne	SHORT ret_double$
+
+ 	mov	rax, QWORD PTR RVALUE[rbp]
+ 	movss	DWORD PTR [rax], xmm0
+ 	jmp	SHORT ret_void$
+
+ret_double$:
+ 	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_DOUBLE
+ 	jne	SHORT ret_sint64$
+
+ 	mov	rax, QWORD PTR RVALUE[rbp]
+ 	movlpd	QWORD PTR [rax], xmm0
+ 	jmp	SHORT ret_void$
+
+ret_sint64$:
+  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT64
+  	jne	ret_void$
+
+ 	mov	rcx, QWORD PTR RVALUE[rbp]
+ 	mov	QWORD PTR [rcx], rax
+ 	jmp	SHORT ret_void$
+	
+ret_void$:
+	xor	rax, rax
+
+	lea	rsp, QWORD PTR [rbp+16]
+	pop	rbp
+	ret	0
+ffi_call_win64 ENDP
+_TEXT	ENDS
+END
+#else        
+.text
+
+.extern ___chkstk
+.extern _ffi_closure_win64_inner
+
+# ffi_closure_win64 will be called with these registers set:
+#    rax points to 'closure'
+#    r11 contains a bit mask that specifies which of the
+#    first four parameters are float or double
+#
+# It must move the parameters passed in registers to their stack location,
+# call ffi_closure_win64_inner for the actual work, then return the result.
+# 
+	.balign 16
+        .globl _ffi_closure_win64	
+_ffi_closure_win64:     
+	# copy register arguments onto stack
+	test	$1,%r11
+	jne	.Lfirst_is_float	
+	mov	%rcx, 8(%rsp)
+	jmp	.Lsecond
+.Lfirst_is_float:
+	movlpd	%xmm0, 8(%rsp)
+
+.Lsecond:
+	test	$2, %r11
+	jne	.Lsecond_is_float	
+	mov	%rdx, 16(%rsp)
+	jmp	.Lthird
+.Lsecond_is_float:
+	movlpd	%xmm1, 16(%rsp)
+
+.Lthird:
+	test	$4, %r11
+	jne	.Lthird_is_float	
+	mov	%r8,24(%rsp)
+	jmp	.Lfourth
+.Lthird_is_float:
+	movlpd	%xmm2, 24(%rsp)
+
+.Lfourth:
+	test	$8, %r11
+	jne	.Lfourth_is_float	
+	mov	%r9, 32(%rsp)
+	jmp	.Ldone
+.Lfourth_is_float:
+	movlpd	%xmm3, 32(%rsp)
+
+.Ldone:
+#.ALLOCSTACK 40
+	sub	$40, %rsp
+#.ENDPROLOG
+	mov	%rax, %rcx	# context is first parameter
+	mov	%rsp, %rdx	# stack is second parameter
+	add	$48, %rdx	# point to start of arguments
+	mov	$_ffi_closure_win64_inner, %rax
+	callq	*%rax		# call the real closure function
+	add	$40, %rsp
+	movq	%rax, %xmm0	# If the closure returned a float,
+                                # ffi_closure_win64_inner wrote it to rax
+	retq
+.ffi_closure_win64_end:
+
+	.balign 16
+        .globl	_ffi_call_win64
+_ffi_call_win64:        
+        # copy registers onto stack
+	mov	%r9,32(%rsp)
+	mov	%r8,24(%rsp)
+	mov	%rdx,16(%rsp)
+	mov	%rcx,8(%rsp)
+        #.PUSHREG rbp
+	push	%rbp
+        #.ALLOCSTACK 48
+	sub	$48,%rsp
+        #.SETFRAME rbp, 32
+	lea	32(%rsp),%rbp
+        #.ENDPROLOG
+
+	mov	CIF_BYTES(%rbp),%eax
+	add	$15, %rax
+	and	$-16, %rax
+	callq	___chkstk
+	cmpq	$0x1000, %rax
+	jb	Lch_done
+Lch_probe:
+	subq	$0x1000,%rsp
+	orl	$0x0, (%rsp)
+	subq	$0x1000,%rax
+	cmpq	$0x1000,%rax
+	ja	Lch_probe
+Lch_done:
+	subq	%rax, %rsp
+	orl	$0x0, (%rsp)
+	lea	32(%rsp), %rax
+	mov	%rax, STACK(%rbp)
+
+	mov	ECIF(%rbp), %rdx
+	mov	STACK(%rbp), %rcx
+	callq	*PREP_ARGS_FN(%rbp)
+
+	mov	STACK(%rbp), %rsp
+
+	movlpd	24(%rsp), %xmm3
+	movd	%xmm3, %r9
+
+	movlpd	16(%rsp), %xmm2
+	movd	%xmm2, %r8
+
+	movlpd	8(%rsp), %xmm1
+	movd	%xmm1, %rdx
+
+	movlpd	(%rsp), %xmm0
+	movd	%xmm0, %rcx
+
+	callq	*FN(%rbp)
+.Lret_struct4b:
+ 	cmpl	$FFI_TYPE_SMALL_STRUCT_4B, CIF_FLAGS(%rbp)
+ 	jne .Lret_struct2b
+
+	mov	RVALUE(%rbp), %rcx
+	mov	%eax, (%rcx)
+	jmp	.Lret_void
+
+.Lret_struct2b:
+	cmpl	$FFI_TYPE_SMALL_STRUCT_2B, CIF_FLAGS(%rbp)
+	jne .Lret_struct1b
+	
+	mov	RVALUE(%rbp), %rcx
+	mov	%ax, (%rcx)
+	jmp .Lret_void
+	
+.Lret_struct1b:
+	cmpl	$FFI_TYPE_SMALL_STRUCT_1B, CIF_FLAGS(%rbp)
+	jne .Lret_uint8
+	
+	mov	RVALUE(%rbp), %rcx
+	mov	%al, (%rcx)
+	jmp .Lret_void
+
+.Lret_uint8:
+	cmpl	$FFI_TYPE_UINT8, CIF_FLAGS(%rbp)
+	jne .Lret_sint8
+	
+        mov     RVALUE(%rbp), %rcx
+        movzbq  %al, %rax
+	movq    %rax, (%rcx)
+	jmp .Lret_void
+
+.Lret_sint8:
+	cmpl	$FFI_TYPE_SINT8, CIF_FLAGS(%rbp)
+	jne .Lret_uint16
+	
+        mov     RVALUE(%rbp), %rcx
+        movsbq  %al, %rax
+	movq    %rax, (%rcx)
+	jmp .Lret_void
+
+.Lret_uint16:
+	cmpl	$FFI_TYPE_UINT16, CIF_FLAGS(%rbp)
+	jne .Lret_sint16
+	
+        mov     RVALUE(%rbp), %rcx
+        movzwq  %ax, %rax
+	movq    %rax, (%rcx)
+	jmp .Lret_void
+
+.Lret_sint16:
+	cmpl	$FFI_TYPE_SINT16, CIF_FLAGS(%rbp)
+	jne .Lret_uint32
+	
+        mov     RVALUE(%rbp), %rcx
+        movswq  %ax, %rax
+	movq    %rax, (%rcx)
+	jmp .Lret_void
+
+.Lret_uint32:
+	cmpl	$FFI_TYPE_UINT32, CIF_FLAGS(%rbp)
+	jne .Lret_sint32
+	
+        mov     RVALUE(%rbp), %rcx
+        movl    %eax, %eax
+	movq    %rax, (%rcx)
+	jmp .Lret_void
+
+.Lret_sint32:
+ 	cmpl	$FFI_TYPE_SINT32, CIF_FLAGS(%rbp)
+ 	jne	.Lret_float
+
+	mov	RVALUE(%rbp), %rcx
+	cltq
+	movq	%rax, (%rcx)
+	jmp	.Lret_void
+
+.Lret_float:
+ 	cmpl	$FFI_TYPE_FLOAT, CIF_FLAGS(%rbp)
+ 	jne	.Lret_double
+
+ 	mov	RVALUE(%rbp), %rax
+ 	movss	%xmm0, (%rax)
+ 	jmp	.Lret_void
+
+.Lret_double:
+ 	cmpl	$FFI_TYPE_DOUBLE, CIF_FLAGS(%rbp)
+ 	jne	.Lret_sint64
+
+ 	mov	RVALUE(%rbp), %rax
+ 	movlpd	%xmm0, (%rax)
+ 	jmp	.Lret_void
+
+.Lret_sint64:
+  	cmpl	$FFI_TYPE_SINT64, CIF_FLAGS(%rbp)
+  	jne	.Lret_void
+
+ 	mov	RVALUE(%rbp), %rcx
+ 	mov	%rax, (%rcx)
+ 	jmp	.Lret_void
+	
+.Lret_void:
+	xor	%rax, %rax
+
+	lea	16(%rbp), %rsp
+	pop	%rbp
+	retq
+.ffi_call_win64_end:
+#endif /* !_MSC_VER */
+
Index: testsuite/Makefile.in
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/Makefile.in,v
retrieving revision 1.6
diff -u -b -w -r1.6 Makefile.in
--- testsuite/Makefile.in	19 Dec 2008 15:47:44 -0000	1.6
+++ testsuite/Makefile.in	10 Jun 2009 10:29:31 -0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -245,8 +245,8 @@
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
 	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
 	      exit 1;; \
 	  esac; \
 	done; \
Index: testsuite/libffi.call/closure_fn0.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_fn0.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 closure_fn0.c
--- testsuite/libffi.call/closure_fn0.c	22 Dec 2008 15:21:15 -0000	1.4
+++ testsuite/libffi.call/closure_fn0.c	10 Jun 2009 10:29:31 -0000
@@ -49,19 +49,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void * code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_uint64;
   cl_arg_types[1] = &ffi_type_sint;
   cl_arg_types[2] = &ffi_type_uint64;
@@ -84,10 +76,10 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,
-			 (void *) 3 /* userdata */) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
 
-  res = (*((closure_test_type0)pcl))
+  res = (*((closure_test_type0)code))
     (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13,
      19, 21, 1);
   /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
Index: testsuite/libffi.call/closure_fn1.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_fn1.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 closure_fn1.c
--- testsuite/libffi.call/closure_fn1.c	22 Dec 2008 15:21:15 -0000	1.4
+++ testsuite/libffi.call/closure_fn1.c	10 Jun 2009 10:29:31 -0000
@@ -41,19 +41,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_float;
   cl_arg_types[1] = &ffi_type_float;
   cl_arg_types[2] = &ffi_type_float;
@@ -76,10 +68,10 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,
-			 (void *) 3 /* userdata */)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn1,
+                             (void *) 3 /* userdata */, code)  == FFI_OK);
 
-  res = (*((closure_test_type1)pcl))
+  res = (*((closure_test_type1)code))
     (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,
      19, 21, 1);
   /* { dg-output "1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255" } */
Index: testsuite/libffi.call/closure_fn2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_fn2.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 closure_fn2.c
--- testsuite/libffi.call/closure_fn2.c	22 Dec 2008 15:21:15 -0000	1.4
+++ testsuite/libffi.call/closure_fn2.c	10 Jun 2009 10:29:31 -0000
@@ -41,19 +41,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_double;
   cl_arg_types[1] = &ffi_type_double;
   cl_arg_types[2] = &ffi_type_double;
@@ -76,10 +68,10 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn2,
-			 (void *) 3 /* userdata */) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn2,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
 
-  res = (*((closure_test_type2)pcl))
+  res = (*((closure_test_type2)code))
     (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,
      19.0, 21, 1);
   /* { dg-output "1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255" } */
Index: testsuite/libffi.call/closure_fn3.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_fn3.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 closure_fn3.c
--- testsuite/libffi.call/closure_fn3.c	22 Dec 2008 15:21:15 -0000	1.4
+++ testsuite/libffi.call/closure_fn3.c	10 Jun 2009 10:29:31 -0000
@@ -42,19 +42,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_float;
   cl_arg_types[1] = &ffi_type_float;
   cl_arg_types[2] = &ffi_type_float;
@@ -77,10 +69,10 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn3,
-			 (void *) 3 /* userdata */)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn3,
+                             (void *) 3 /* userdata */, code)  == FFI_OK);
 
-  res = (*((closure_test_type3)pcl))
+  res = (*((closure_test_type3)code))
     (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,
      19.19, 21.21, 1);
   /* { dg-output "1 2 3 4 5 6 7 8 9 10 11 12 13 19 21 1 3: 135" } */
Index: testsuite/libffi.call/closure_fn4.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_fn4.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 closure_fn4.c
--- testsuite/libffi.call/closure_fn4.c	22 Dec 2008 15:21:15 -0000	1.4
+++ testsuite/libffi.call/closure_fn4.c	10 Jun 2009 10:29:31 -0000
@@ -60,19 +60,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int i, res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   for (i = 0; i < 15; i++) {
     cl_arg_types[i] = &ffi_type_uint64;
   }
@@ -83,10 +75,10 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,
-			 (void *) 3 /* userdata */) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
 
-  res = (*((closure_test_type0)pcl))
+  res = (*((closure_test_type0)code))
     (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11LL, 12LL,
      13LL, 19LL, 21LL, 1);
   /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
Index: testsuite/libffi.call/closure_fn5.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_fn5.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 closure_fn5.c
--- testsuite/libffi.call/closure_fn5.c	22 Dec 2008 15:21:15 -0000	1.4
+++ testsuite/libffi.call/closure_fn5.c	10 Jun 2009 10:29:31 -0000
@@ -59,17 +59,10 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int i, res;
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
 
   for (i = 0; i < 10; i++) {
     cl_arg_types[i] = &ffi_type_uint64;
@@ -85,10 +78,10 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn5,
-			 (void *) 3 /* userdata */) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn5,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
 
-  res = (*((closure_test_type0)pcl))
+  res = (*((closure_test_type0)code))
     (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11, 12LL,
      13LL, 19LL, 21LL, 1);
   /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
Index: testsuite/libffi.call/closure_fn6.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_fn6.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 closure_fn6.c
--- testsuite/libffi.call/closure_fn6.c	22 Dec 2008 15:21:15 -0000	1.3
+++ testsuite/libffi.call/closure_fn6.c	10 Jun 2009 10:29:31 -0000
@@ -50,19 +50,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_uint64;
   cl_arg_types[1] = &ffi_type_uint64;
   cl_arg_types[2] = &ffi_type_uint64;
@@ -85,10 +77,10 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,
-			 (void *) 3 /* userdata */) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
 
-  res = (*((closure_test_type0)pcl))
+  res = (*((closure_test_type0)code))
     (1, 2, 3, 4, 127, 429., 7., 8., 9.5, 10., 11, 12., 13,
      19, 21., 1.);
   /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
Index: testsuite/libffi.call/closure_stdcall.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/closure_stdcall.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 closure_stdcall.c
--- testsuite/libffi.call/closure_stdcall.c	22 Dec 2008 15:21:15 -0000	1.2
+++ testsuite/libffi.call/closure_stdcall.c	10 Jun 2009 10:29:31 -0000
@@ -28,22 +28,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
   int res;
   void* sp_pre;
   void* sp_post;
   char buf[1024];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_uint;
   cl_arg_types[1] = &ffi_type_uint;
   cl_arg_types[2] = &ffi_type_uint;
@@ -54,11 +46,11 @@
   CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 4,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, closure_test_stdcall,
-			 (void *) 3 /* userdata */) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_stdcall,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
 
   asm volatile (" movl %%esp,%0" : "=g" (sp_pre));
-  res = (*(closure_test_type0)pcl)(0, 1, 2, 3);
+  res = (*(closure_test_type0)code)(0, 1, 2, 3);
   asm volatile (" movl %%esp,%0" : "=g" (sp_post));
   /* { dg-output "0 1 2 3: 9" } */
 
Index: testsuite/libffi.call/cls_12byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_12byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_12byte.c
--- testsuite/libffi.call/cls_12byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_12byte.c	10 Jun 2009 10:29:31 -0000
@@ -42,21 +42,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -87,13 +79,13 @@
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 8 9 12" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_12byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_12byte_gn, NULL, code) == FFI_OK);
 
   res_dbl.a = 0;
   res_dbl.b = 0;
   res_dbl.c = 0;
 
-  res_dbl = ((cls_struct_12byte(*)(cls_struct_12byte, cls_struct_12byte))(pcl))(h_dbl, j_dbl);
+  res_dbl = ((cls_struct_12byte(*)(cls_struct_12byte, cls_struct_12byte))(code))(h_dbl, j_dbl);
   /* { dg-output "\n7 4 9 1 5 3: 8 9 12" } */
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 8 9 12" } */
Index: testsuite/libffi.call/cls_16byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_16byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_16byte.c
--- testsuite/libffi.call/cls_16byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_16byte.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -92,9 +84,9 @@
   res_dbl.b = 0.0;
   res_dbl.c = 0;
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_16byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_16byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_16byte(*)(cls_struct_16byte, cls_struct_16byte))(pcl))(h_dbl, j_dbl);
+  res_dbl = ((cls_struct_16byte(*)(cls_struct_16byte, cls_struct_16byte))(code))(h_dbl, j_dbl);
   /* { dg-output "\n7 8 9 1 9 3: 8 17 12" } */
   printf("res: %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 8 17 12" } */
Index: testsuite/libffi.call/cls_18byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_18byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_18byte.c
--- testsuite/libffi.call/cls_18byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_18byte.c	10 Jun 2009 10:29:31 -0000
@@ -47,21 +47,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[5];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -93,9 +85,9 @@
   printf("res: %g %d %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 5 252 250 8" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_18byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_18byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_18byte(*)(cls_struct_18byte, cls_struct_18byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_18byte(*)(cls_struct_18byte, cls_struct_18byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n1 127 126 3 4 125 124 5: 5 252 250 8" } */
   printf("res: %g %d %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 5 252 250 8" } */
Index: testsuite/libffi.call/cls_19byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_19byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_19byte.c
--- testsuite/libffi.call/cls_19byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_19byte.c	10 Jun 2009 10:29:31 -0000
@@ -50,21 +50,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[6];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -98,9 +90,9 @@
 	 res_dbl.d, res_dbl.e);
   /* { dg-output "\nres: 5 252 250 8 239" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_19byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_19byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_19byte(*)(cls_struct_19byte, cls_struct_19byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_19byte(*)(cls_struct_19byte, cls_struct_19byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n1 127 126 3 120 4 125 124 5 119: 5 252 250 8 239" } */
   printf("res: %g %d %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
 	 res_dbl.d, res_dbl.e);
Index: testsuite/libffi.call/cls_1_1byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_1_1byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_1_1byte.c
--- testsuite/libffi.call/cls_1_1byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_1_1byte.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[2];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -86,9 +78,9 @@
   printf("res: %d\n", res_dbl.a);
   /* { dg-output "\nres: 190" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_1_1byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_1_1byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_1_1byte(*)(cls_struct_1_1byte, cls_struct_1_1byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_1_1byte(*)(cls_struct_1_1byte, cls_struct_1_1byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 178: 190" } */
   printf("res: %d\n", res_dbl.a);
   /* { dg-output "\nres: 190" } */
Index: testsuite/libffi.call/cls_20byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_20byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_20byte.c
--- testsuite/libffi.call/cls_20byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_20byte.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -88,9 +80,9 @@
   printf("res: %g %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 5 7 10" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_20byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_20byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n1 2 3 4 5 7: 5 7 10" } */
   printf("res: %g %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 5 7 10" } */
Index: testsuite/libffi.call/cls_20byte1.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_20byte1.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_20byte1.c
--- testsuite/libffi.call/cls_20byte1.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_20byte1.c	10 Jun 2009 10:29:31 -0000
@@ -45,21 +45,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -90,9 +82,9 @@
   printf("res: %d %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 5 7 10" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_20byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_20byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n1 2 3 4 5 7: 5 7 10" } */
   printf("res: %d %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 5 7 10" } */
Index: testsuite/libffi.call/cls_24byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_24byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_24byte.c
--- testsuite/libffi.call/cls_24byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_24byte.c	10 Jun 2009 10:29:31 -0000
@@ -54,21 +54,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[5];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -106,13 +98,13 @@
   printf("res: %g %g %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 22 15 17 25" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_24byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_24byte_gn, NULL, code) == FFI_OK);
 
   res_dbl = ((cls_struct_24byte(*)(cls_struct_24byte,
 				   cls_struct_24byte,
 				   cls_struct_24byte,
 				   cls_struct_24byte))
-	     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);
+	     (code))(e_dbl, f_dbl, g_dbl, h_dbl);
   /* { dg-output "\n9 2 6 5 1 2 3 7 4 5 7 9 8 6 1 9: 22 15 17 25" } */
   printf("res: %g %g %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 22 15 17 25" } */
Index: testsuite/libffi.call/cls_2byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_2byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_2byte.c
--- testsuite/libffi.call/cls_2byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_2byte.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -87,9 +79,9 @@
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 13 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_2byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_2byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_2byte(*)(cls_struct_2byte, cls_struct_2byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_2byte(*)(cls_struct_2byte, cls_struct_2byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 127 1 13: 13 140" } */
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 13 140" } */
Index: testsuite/libffi.call/cls_3_1byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_3_1byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_3_1byte.c
--- testsuite/libffi.call/cls_3_1byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_3_1byte.c	10 Jun 2009 10:29:31 -0000
@@ -47,21 +47,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -92,9 +84,9 @@
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 190 192 194" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3_1byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3_1byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_3_1byte(*)(cls_struct_3_1byte, cls_struct_3_1byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_3_1byte(*)(cls_struct_3_1byte, cls_struct_3_1byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 13 14 178 179 180: 190 192 194" } */
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 190 192 194" } */
Index: testsuite/libffi.call/cls_3byte1.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_3byte1.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_3byte1.c
--- testsuite/libffi.call/cls_3byte1.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_3byte1.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -87,9 +79,9 @@
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 13 134" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_3byte(*)(cls_struct_3byte, cls_struct_3byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_3byte(*)(cls_struct_3byte, cls_struct_3byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 119 1 15: 13 134" } */
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 13 134" } */
Index: testsuite/libffi.call/cls_3byte2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_3byte2.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_3byte2.c
--- testsuite/libffi.call/cls_3byte2.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_3byte2.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -87,9 +79,9 @@
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 24 144" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3byte_gn1, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3byte_gn1, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_3byte_1(*)(cls_struct_3byte_1, cls_struct_3byte_1))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_3byte_1(*)(cls_struct_3byte_1, cls_struct_3byte_1))(code))(g_dbl, f_dbl);
   /* { dg-output "\n15 125 9 19: 24 144" } */
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 24 144" } */
Index: testsuite/libffi.call/cls_4_1byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_4_1byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_4_1byte.c
--- testsuite/libffi.call/cls_4_1byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_4_1byte.c	10 Jun 2009 10:29:31 -0000
@@ -49,21 +49,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[5];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -95,9 +87,9 @@
   printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 190 192 194 196" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_4_1byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_4_1byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_4_1byte(*)(cls_struct_4_1byte, cls_struct_4_1byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_4_1byte(*)(cls_struct_4_1byte, cls_struct_4_1byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 13 14 15 178 179 180 181: 190 192 194 196" } */
   printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 190 192 194 196" } */
Index: testsuite/libffi.call/cls_4byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_4byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_4byte.c
--- testsuite/libffi.call/cls_4byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_4byte.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -87,9 +79,9 @@
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 139 248" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_4byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_4byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_4byte(*)(cls_struct_4byte, cls_struct_4byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_4byte(*)(cls_struct_4byte, cls_struct_4byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n127 120 12 128: 139 248" } */
   printf("res: %d %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 139 248" } */
Index: testsuite/libffi.call/cls_5_1_byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_5_1_byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_5_1_byte.c
--- testsuite/libffi.call/cls_5_1_byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_5_1_byte.c	10 Jun 2009 10:29:31 -0000
@@ -51,21 +51,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[6];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -105,9 +97,9 @@
   res_dbl.d = 0;
   res_dbl.e = 0;
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_5byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_5byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n127 120 1 3 4 12 128 9 3 4: 139 248 10 6 8" } */
   printf("res: %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
 	 res_dbl.d, res_dbl.e);
Index: testsuite/libffi.call/cls_5byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_5byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_5byte.c
--- testsuite/libffi.call/cls_5byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_5byte.c	10 Jun 2009 10:29:31 -0000
@@ -46,21 +46,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -95,9 +87,9 @@
   res_dbl.b = 0;
   res_dbl.c = 0;
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_5byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_5byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n127 120 1 12 128 9: 139 248 10" } */
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 139 248 10" } */
Index: testsuite/libffi.call/cls_64byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_64byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_64byte.c
--- testsuite/libffi.call/cls_64byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_64byte.c	10 Jun 2009 10:29:31 -0000
@@ -59,21 +59,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[9];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -116,13 +108,13 @@
 	 res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h);
   /* { dg-output "\nres: 22 15 17 25 6 13 19 18" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_64byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_64byte_gn, NULL, code) == FFI_OK);
 
   res_dbl = ((cls_struct_64byte(*)(cls_struct_64byte,
 				   cls_struct_64byte,
 				   cls_struct_64byte,
 				   cls_struct_64byte))
-	     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);
+	     (code))(e_dbl, f_dbl, g_dbl, h_dbl);
   /* { dg-output "\n22 15 17 25 6 13 19 18" } */
   printf("res: %g %g %g %g %g %g %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c,
 	 res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h);
Index: testsuite/libffi.call/cls_6_1_byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_6_1_byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_6_1_byte.c
--- testsuite/libffi.call/cls_6_1_byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_6_1_byte.c	10 Jun 2009 10:29:31 -0000
@@ -53,21 +53,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[7];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -109,9 +101,9 @@
   res_dbl.e = 0;
   res_dbl.f = 0;
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_6byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_6byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n127 120 1 3 4 5 12 128 9 3 4 5: 139 248 10 6 8 10" } */
   printf("res: %d %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
 	 res_dbl.d, res_dbl.e, res_dbl.f);
Index: testsuite/libffi.call/cls_6byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_6byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_6byte.c
--- testsuite/libffi.call/cls_6byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_6byte.c	10 Jun 2009 10:29:31 -0000
@@ -49,21 +49,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[5];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -95,9 +87,9 @@
   printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 139 248 10 255" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_6byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_6byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n127 120 1 128 12 128 9 127: 139 248 10 255" } */
   printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 139 248 10 255" } */
Index: testsuite/libffi.call/cls_7_1_byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_7_1_byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_7_1_byte.c
--- testsuite/libffi.call/cls_7_1_byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_7_1_byte.c	10 Jun 2009 10:29:31 -0000
@@ -55,21 +55,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[8];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -113,9 +105,9 @@
   res_dbl.f = 0;
   res_dbl.g = 0;
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_7byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_7byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n127 120 1 3 4 5 6 12 128 9 3 4 5 6: 139 248 10 6 8 10 12" } */
   printf("res: %d %d %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
 	 res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
Index: testsuite/libffi.call/cls_7byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_7byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_7byte.c
--- testsuite/libffi.call/cls_7byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_7byte.c	10 Jun 2009 10:29:31 -0000
@@ -48,21 +48,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[5];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -94,9 +86,9 @@
   printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 139 248 10 509" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_7byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_7byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n127 120 1 254 12 128 9 255: 139 248 10 509" } */
   printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
   /* { dg-output "\nres: 139 248 10 509" } */
Index: testsuite/libffi.call/cls_8byte.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_8byte.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_8byte.c
--- testsuite/libffi.call/cls_8byte.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_8byte.c	10 Jun 2009 10:29:31 -0000
@@ -42,21 +42,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -85,9 +77,9 @@
   /* { dg-output "1 2 4 5: 5 7" } */
   printf("res: %d %g\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 5 7" } */
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_8byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_8byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_8byte(*)(cls_struct_8byte, cls_struct_8byte))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_8byte(*)(cls_struct_8byte, cls_struct_8byte))(code))(g_dbl, f_dbl);
   /* { dg-output "\n1 2 4 5: 5 7" } */
   printf("res: %d %g\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 5 7" } */
Index: testsuite/libffi.call/cls_9byte1.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_9byte1.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_9byte1.c
--- testsuite/libffi.call/cls_9byte1.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_9byte1.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[3];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -87,9 +79,9 @@
   printf("res: %d %g\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 8 17" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_9byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_9byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(pcl))(h_dbl, j_dbl);
+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(code))(h_dbl, j_dbl);
   /* { dg-output "\n7 8 1 9: 8 17" } */
   printf("res: %d %g\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 8 17" } */
Index: testsuite/libffi.call/cls_9byte2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_9byte2.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_9byte2.c
--- testsuite/libffi.call/cls_9byte2.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_9byte2.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[3];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -88,9 +80,9 @@
   /* { dg-output "\nres: 8 17" } */
 
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_9byte_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_9byte_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(pcl))(h_dbl, j_dbl);
+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(code))(h_dbl, j_dbl);
   /* { dg-output "\n7 8 1 9: 8 17" } */
   printf("res: %g %d\n", res_dbl.a, res_dbl.b);
   /* { dg-output "\nres: 8 17" } */
Index: testsuite/libffi.call/cls_align_double.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_double.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_double.c
--- testsuite/libffi.call/cls_align_double.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_double.c	10 Jun 2009 10:29:31 -0000
@@ -45,21 +45,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -90,9 +82,9 @@
   printf("res: %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_float.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_float.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_float.c
--- testsuite/libffi.call/cls_align_float.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_float.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -88,9 +80,9 @@
   printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_longdouble.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_longdouble.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 cls_align_longdouble.c
--- testsuite/libffi.call/cls_align_longdouble.c	26 Dec 2008 19:06:28 -0000	1.4
+++ testsuite/libffi.call/cls_align_longdouble.c	10 Jun 2009 10:29:31 -0000
@@ -4,7 +4,7 @@
    PR:		none.
    Originator:	<hos@tamanegi.org> 20031203	 */
 
-/* { dg-do run { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-do run } */
 
 #include "ffitest.h"
 
@@ -44,21 +44,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -89,9 +81,9 @@
   printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_longdouble_split.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_longdouble_split.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 cls_align_longdouble_split.c
--- testsuite/libffi.call/cls_align_longdouble_split.c	26 Dec 2008 19:06:28 -0000	1.2
+++ testsuite/libffi.call/cls_align_longdouble_split.c	10 Jun 2009 10:29:31 -0000
@@ -4,8 +4,10 @@
    PR:		none.
    Originator:	<hos@tamanegi.org> 20031203	 */
 
-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-excess-errors "no long double format" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 /* { dg-options -mlong-double-128 { target powerpc64*-*-* } } */
+/* { dg-output "" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
 
 #include "ffitest.h"
 
@@ -78,21 +80,13 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args_dbl[3];
 	ffi_type* cls_struct_fields[8];
 	ffi_type cls_struct_type;
 	ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	cls_struct_type.size = 0;
 	cls_struct_type.alignment = 0;
 	cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -128,9 +122,9 @@
 		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
 	/* { dg-output "\nres: 9 11 13 15 17 19 21" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-	res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+	res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
 	/* { dg-output "\n1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21" } */
 	printf("res: %Lg %Lg %Lg %Lg %Lg %Lg %Lg\n", res_dbl.a, res_dbl.b,
 		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
Index: testsuite/libffi.call/cls_align_longdouble_split2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_longdouble_split2.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 cls_align_longdouble_split2.c
--- testsuite/libffi.call/cls_align_longdouble_split2.c	26 Dec 2008 19:06:28 -0000	1.2
+++ testsuite/libffi.call/cls_align_longdouble_split2.c	10 Jun 2009 10:29:31 -0000
@@ -5,8 +5,10 @@
 	Originator:		Blake Chaffin	6/18/2007
 */
 
-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-excess-errors "no long double format" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* } } */
 /* { dg-options -mlong-double-128 { target powerpc64*-*-* } } */
+/* { dg-output "" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
 
 #include "ffitest.h"
 
@@ -58,21 +60,13 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args_dbl[3];
 	ffi_type* cls_struct_fields[8];
 	ffi_type cls_struct_type;
 	ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	cls_struct_type.size = 0;
 	cls_struct_type.alignment = 0;
 	cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -108,9 +102,9 @@
 		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
 	/* { dg-output "\nres: 9 11 13 15 17 19 21" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-	res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+	res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
 	/* { dg-output "\n1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21" } */
 	printf("res: %Lg %Lg %Lg %Lg %Lg %g %Lg\n", res_dbl.a, res_dbl.b,
 		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
@@ -118,3 +112,6 @@
 
   exit(0);
 }
+
+
+
Index: testsuite/libffi.call/cls_align_pointer.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_pointer.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 cls_align_pointer.c
--- testsuite/libffi.call/cls_align_pointer.c	22 Dec 2008 15:21:15 -0000	1.4
+++ testsuite/libffi.call/cls_align_pointer.c	10 Jun 2009 10:29:31 -0000
@@ -47,21 +47,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -92,9 +84,9 @@
   printf("res: %d %" PRIuPTR " %d\n", res_dbl.a, (uintptr_t)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %" PRIuPTR " %d\n", res_dbl.a, (uintptr_t)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_sint16.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_sint16.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_sint16.c
--- testsuite/libffi.call/cls_align_sint16.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_sint16.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -88,9 +80,9 @@
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_sint32.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_sint32.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_sint32.c
--- testsuite/libffi.call/cls_align_sint32.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_sint32.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -88,9 +80,9 @@
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_sint64.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_sint64.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_sint64.c
--- testsuite/libffi.call/cls_align_sint64.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_sint64.c	10 Jun 2009 10:29:31 -0000
@@ -22,7 +22,7 @@
   result.b = a1.b + a2.b;
   result.c = a1.c + a2.c;
 
-  printf("%d %lld %d %d %lld %d: %d %lld %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+  printf("%d %" PRId64 " %d %d %" PRId64 " %d: %d %" PRId64 " %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
 
   return  result;
 }
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -85,14 +77,14 @@
 
   ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
   /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
-  printf("res: %d %lld %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  printf("res: %d %" PRId64 " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
-  printf("res: %d %lld %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  printf("res: %d %" PRId64 " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
   exit(0);
Index: testsuite/libffi.call/cls_align_uint16.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_uint16.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_uint16.c
--- testsuite/libffi.call/cls_align_uint16.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_uint16.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -88,9 +80,9 @@
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_uint32.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_uint32.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_uint32.c
--- testsuite/libffi.call/cls_align_uint32.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_uint32.c	10 Jun 2009 10:29:31 -0000
@@ -43,21 +43,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -88,9 +80,9 @@
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
   printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
Index: testsuite/libffi.call/cls_align_uint64.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_align_uint64.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_align_uint64.c
--- testsuite/libffi.call/cls_align_uint64.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_align_uint64.c	10 Jun 2009 10:29:31 -0000
@@ -23,7 +23,7 @@
   result.b = a1.b + a2.b;
   result.c = a1.c + a2.c;
 
-  printf("%d %lld %d %d %lld %d: %d %lld %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+  printf("%d %" PRId64 " %d %d %" PRId64 " %d: %d %" PRId64 " %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
 
   return  result;
 }
@@ -44,21 +44,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[4];
   ffi_type cls_struct_type;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -86,14 +78,14 @@
 
   ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
   /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
-  printf("res: %d %lld %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  printf("res: %d %" PRId64 " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
-  printf("res: %d %lld %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  printf("res: %d %" PRId64 " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
   exit(0);
Index: testsuite/libffi.call/cls_dbls_struct.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_dbls_struct.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_dbls_struct.c
--- testsuite/libffi.call/cls_dbls_struct.c	8 Jun 2009 16:50:49 -0000	1.3
+++ testsuite/libffi.call/cls_dbls_struct.c	10 Jun 2009 10:29:31 -0000
@@ -30,19 +30,10 @@
 {
 	ffi_cif cif;
 
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-
-	ffi_closure*	pcl;
+        void *code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	ffi_type*		cl_arg_types[1];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap(sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	ffi_type	ts1_type;
 	ffi_type*	ts1_type_elements[4];
 
@@ -63,9 +54,9 @@
 	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 				 &ffi_type_void, cl_arg_types) == FFI_OK);
 
-	CHECK(ffi_prep_closure(pcl, &cif, closure_test_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_gn, NULL, code) == FFI_OK);
 
-	((void*(*)(Dbls))(pcl))(arg);
+	((void*(*)(Dbls))(code))(arg);
 	/* { dg-output "1.0 2.0\n" { xfail x86_64-*-linux-* } } */
 
 	closure_test_fn(arg);
Index: testsuite/libffi.call/cls_double.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_double.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_double.c
--- testsuite/libffi.call/cls_double.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_double.c	10 Jun 2009 10:29:31 -0000
@@ -20,19 +20,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   double res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_double;
   cl_arg_types[1] = NULL;
 
@@ -40,9 +32,9 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_double, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_double_fn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_double_fn, NULL, code)  == FFI_OK);
 
-  res = (*((cls_ret_double)pcl))(21474.789);
+  res = (*((cls_ret_double)code))(21474.789);
   /* { dg-output "21474.789000: 21474.789000" } */
   printf("res: %.6f\n", res);
   /* { dg-output "\nres: 21474.789000" } */
Index: testsuite/libffi.call/cls_double_va.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_double_va.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 cls_double_va.c
--- testsuite/libffi.call/cls_double_va.c	24 Jul 2008 18:03:48 -0000	1.2
+++ testsuite/libffi.call/cls_double_va.c	10 Jun 2009 10:29:31 -0000
@@ -20,19 +20,11 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args[3];
 	ffi_type* arg_types[3];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap(sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	char*	format		= "%.1f\n";
 	double	doubleArg	= 7;
 	ffi_arg	res			= 0;
@@ -53,9 +45,9 @@
 	printf("res: %d\n", (int) res);
 	// { dg-output "\nres: 4" }
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_double_va_fn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_double_va_fn, NULL, code) == FFI_OK);
 
-	res	= ((int(*)(char*, double))(pcl))(format, doubleArg);
+	res	= ((int(*)(char*, double))(code))(format, doubleArg);
 	// { dg-output "\n7.0" }
 	printf("res: %d\n", (int) res);
 	// { dg-output "\nres: 4" }
Index: testsuite/libffi.call/cls_float.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_float.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_float.c
--- testsuite/libffi.call/cls_float.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_float.c	10 Jun 2009 10:29:31 -0000
@@ -21,20 +21,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   float res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
-
   cl_arg_types[0] = &ffi_type_float;
   cl_arg_types[1] = NULL;
 
@@ -42,8 +33,8 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_float, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_float_fn, NULL)  == FFI_OK);
-  res = ((((cls_ret_float)pcl)(-2122.12)));
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_float_fn, NULL, code)  == FFI_OK);
+  res = ((((cls_ret_float)code)(-2122.12)));
   /* { dg-output "\\-2122.12: \\-2122.12" } */
   printf("res: %.6f\n", res);
   /* { dg-output "\nres: \-2122.120117" } */
Index: testsuite/libffi.call/cls_longdouble.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_longdouble.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 cls_longdouble.c
--- testsuite/libffi.call/cls_longdouble.c	27 Dec 2008 16:59:05 -0000	1.4
+++ testsuite/libffi.call/cls_longdouble.c	10 Jun 2009 10:29:31 -0000
@@ -4,8 +4,10 @@
    PR:			none.
    Originator:	Blake Chaffin	*/
 
-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-excess-errors "no long double format" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 /* { dg-options -mlong-double-128 { target powerpc64*-*-* } } */
+/* { dg-output "" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
 
 #include "ffitest.h"
 
@@ -47,20 +49,12 @@
 int main(void)
 {
 	ffi_cif	cif;
-#ifndef USING_MMAP
-	static ffi_closure	cl;
-#endif
-	ffi_closure*	pcl;
+        void* code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void*			args[9];
 	ffi_type*		arg_types[9];
 	long double		res	= 0;
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap(sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	long double	arg1	= 1;
 	long double	arg2	= 2;
 	long double	arg3	= 3;
@@ -98,10 +92,10 @@
 	printf("res: %Lg\n", res);
 	/* { dg-output "\nres: 36" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_ldouble_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ldouble_gn, NULL, code) == FFI_OK);
 
 	res = ((long double(*)(long double, long double, long double, long double,
-		long double, long double, long double, long double))(pcl))(arg1, arg2,
+		long double, long double, long double, long double))(code))(arg1, arg2,
 		arg3, arg4, arg5, arg6, arg7, arg8);
 	/* { dg-output "\n1 2 3 4 5 6 7 8: 36" } */
 	printf("res: %Lg\n", res);
Index: testsuite/libffi.call/cls_longdouble_va.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_longdouble_va.c,v
retrieving revision 1.4
diff -u -b -w -r1.4 cls_longdouble_va.c
--- testsuite/libffi.call/cls_longdouble_va.c	8 Jun 2009 16:50:49 -0000	1.4
+++ testsuite/libffi.call/cls_longdouble_va.c	10 Jun 2009 10:29:31 -0000
@@ -4,7 +4,8 @@
    PR:			none.
    Originator:	Blake Chaffin 6/6/2007	 */
 
-/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
+/* { dg-output "" { xfail x86_64-*-mingw* } } */
 #include "ffitest.h"
 
 static void
@@ -20,19 +21,11 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args[3];
 	ffi_type* arg_types[3];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	char*		format	= "%L.1f\n";
 	long double	ldArg	= 7;
 	ffi_arg		res		= 0;
@@ -53,9 +46,9 @@
 	printf("res: %d\n", (int) res);
 	// { dg-output "\nres: 4" { xfail i*86-*-linux-* x86_64-*-linux-* } }
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_longdouble_va_fn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_longdouble_va_fn, NULL, code) == FFI_OK);
 
-	res	= ((int(*)(char*, long double))(pcl))(format, ldArg);
+	res	= ((int(*)(char*, long double))(code))(format, ldArg);
 	// { dg-output "\n7.0" }
 	printf("res: %d\n", (int) res);
 	// { dg-output "\nres: 4" }
Index: testsuite/libffi.call/cls_multi_schar.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_multi_schar.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_multi_schar.c
--- testsuite/libffi.call/cls_multi_schar.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_multi_schar.c	10 Jun 2009 10:29:31 -0000
@@ -36,21 +36,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void * args_dbl[3];
   ffi_type * cl_arg_types[3];
   ffi_arg res_call;
   signed char a, b, res_closure;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   a = 2;
   b = 125;
 
@@ -71,9 +63,9 @@
   printf("res: %d\n", (signed char)res_call);
   /* { dg-output "\nres: 127" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
 
-  res_closure = (*((test_type)pcl))(2, 125);
+  res_closure = (*((test_type)code))(2, 125);
   /* { dg-output "\n2 125: 127" } */
   printf("res: %d\n", res_closure);
   /* { dg-output "\nres: 127" } */
Index: testsuite/libffi.call/cls_multi_sshort.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_multi_sshort.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_multi_sshort.c
--- testsuite/libffi.call/cls_multi_sshort.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_multi_sshort.c	10 Jun 2009 10:29:31 -0000
@@ -36,21 +36,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void * args_dbl[3];
   ffi_type * cl_arg_types[3];
   ffi_arg res_call;
   unsigned short a, b, res_closure;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   a = 2;
   b = 32765;
 
@@ -71,9 +63,9 @@
   printf("res: %d\n", (unsigned short)res_call);
   /* { dg-output "\nres: 32767" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
 
-  res_closure = (*((test_type)pcl))(2, 32765);
+  res_closure = (*((test_type)code))(2, 32765);
   /* { dg-output "\n2 32765: 32767" } */
   printf("res: %d\n", res_closure);
   /* { dg-output "\nres: 32767" } */
Index: testsuite/libffi.call/cls_multi_sshortchar.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_multi_sshortchar.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_multi_sshortchar.c
--- testsuite/libffi.call/cls_multi_sshortchar.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_multi_sshortchar.c	10 Jun 2009 10:29:31 -0000
@@ -41,22 +41,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void * args_dbl[5];
   ffi_type * cl_arg_types[5];
   ffi_arg res_call;
   signed char a, c;
   signed short b, d, res_closure;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   a = 1;
   b = 32765;
   c = 127;
@@ -83,9 +75,9 @@
   printf("res: %d\n", (signed short)res_call);
   /* { dg-output "\nres: 32765" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
 
-  res_closure = (*((test_type)pcl))(1, 32765, 127, -128);
+  res_closure = (*((test_type)code))(1, 32765, 127, -128);
   /* { dg-output "\n1 32765 127 -128: 32765" } */
   printf("res: %d\n", res_closure);
   /* { dg-output "\nres: 32765" } */
Index: testsuite/libffi.call/cls_multi_uchar.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_multi_uchar.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_multi_uchar.c
--- testsuite/libffi.call/cls_multi_uchar.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_multi_uchar.c	10 Jun 2009 10:29:31 -0000
@@ -47,21 +47,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void * args_dbl[5];
   ffi_type * cl_arg_types[5];
   ffi_arg res_call;
   unsigned char a, b, c, d, res_closure;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   a = 1;
   b = 2;
   c = 127;
@@ -88,9 +80,9 @@
   printf("res: %d\n", (unsigned char)res_call);
   /* { dg-output "\nres: 255" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
 
-  res_closure = (*((test_type)pcl))(1, 2, 127, 125);
+  res_closure = (*((test_type)code))(1, 2, 127, 125);
   /* { dg-output "\n1 2 127 125: 255" } */
   printf("res: %d\n", res_closure);
   /* { dg-output "\nres: 255" } */
Index: testsuite/libffi.call/cls_multi_ushort.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_multi_ushort.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_multi_ushort.c
--- testsuite/libffi.call/cls_multi_ushort.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_multi_ushort.c	10 Jun 2009 10:29:31 -0000
@@ -36,21 +36,13 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void * args_dbl[3];
   ffi_type * cl_arg_types[3];
   ffi_arg res_call;
   unsigned short a, b, res_closure;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   a = 2;
   b = 32765;
 
@@ -71,9 +63,9 @@
   printf("res: %d\n", (unsigned short)res_call);
   /* { dg-output "\nres: 32767" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
 
-  res_closure = (*((test_type)pcl))(2, 32765);
+  res_closure = (*((test_type)code))(2, 32765);
   /* { dg-output "\n2 32765: 32767" } */
   printf("res: %d\n", res_closure);
   /* { dg-output "\nres: 32767" } */
Index: testsuite/libffi.call/cls_multi_ushortchar.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_multi_ushortchar.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_multi_ushortchar.c
--- testsuite/libffi.call/cls_multi_ushortchar.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_multi_ushortchar.c	10 Jun 2009 10:29:31 -0000
@@ -41,22 +41,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void * args_dbl[5];
   ffi_type * cl_arg_types[5];
   ffi_arg res_call;
   unsigned char a, c;
   unsigned short b, d, res_closure;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   a = 1;
   b = 2;
   c = 127;
@@ -83,9 +75,9 @@
   printf("res: %d\n", (unsigned short)res_call);
   /* { dg-output "\nres: 258" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
 
-  res_closure = (*((test_type)pcl))(1, 2, 127, 128);
+  res_closure = (*((test_type)code))(1, 2, 127, 128);
   /* { dg-output "\n1 2 127 128: 258" } */
   printf("res: %d\n", res_closure);
   /* { dg-output "\nres: 258" } */
Index: testsuite/libffi.call/cls_pointer.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_pointer.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_pointer.c
--- testsuite/libffi.call/cls_pointer.c	22 Dec 2008 15:21:15 -0000	1.3
+++ testsuite/libffi.call/cls_pointer.c	10 Jun 2009 10:29:31 -0000
@@ -32,20 +32,12 @@
 int main (void)
 {
 	ffi_cif	cif;
-#ifndef USING_MMAP
-	static ffi_closure	cl;
-#endif
-	ffi_closure*	pcl;
+        void *code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void*			args[3];
 //	ffi_type		cls_pointer_type;
 	ffi_type*		arg_types[3];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap(sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 /*	cls_pointer_type.size = sizeof(void*);
 	cls_pointer_type.alignment = 0;
 	cls_pointer_type.type = FFI_TYPE_POINTER;
@@ -71,9 +63,9 @@
 	printf("res: 0x%08x\n", (unsigned int) res);
 	/* { dg-output "\nres: 0x9be02467" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_pointer_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);
 
-	res = (ffi_arg)((void*(*)(void*, void*))(pcl))(arg1, arg2);
+	res = (ffi_arg)((void*(*)(void*, void*))(code))(arg1, arg2);
 	/* { dg-output "\n0x12345678 0x89abcdef: 0x9be02467" } */
 	printf("res: 0x%08x\n", (unsigned int) res);
 	/* { dg-output "\nres: 0x9be02467" } */
Index: testsuite/libffi.call/cls_pointer_stack.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_pointer_stack.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_pointer_stack.c
--- testsuite/libffi.call/cls_pointer_stack.c	22 Dec 2008 15:21:15 -0000	1.3
+++ testsuite/libffi.call/cls_pointer_stack.c	10 Jun 2009 10:29:31 -0000
@@ -93,20 +93,12 @@
 int main (void)
 {
 	ffi_cif	cif;
-#ifndef USING_MMAP
-	static ffi_closure	cl;
-#endif
-	ffi_closure*	pcl;
+        void *code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void*			args[3];
 //	ffi_type		cls_pointer_type;
 	ffi_type*		arg_types[3];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap(sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 /*	cls_pointer_type.size = sizeof(void*);
 	cls_pointer_type.alignment = 0;
 	cls_pointer_type.type = FFI_TYPE_POINTER;
@@ -135,9 +127,9 @@
 	// { dg-output "\n0x8acf1356 0x01234567: 0x8bf258bd" }
 	// { dg-output "\nres: 0x8bf258bd" }
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_pointer_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);
 
-	res = (ffi_arg)((void*(*)(void*, void*))(pcl))(arg1, arg2);
+	res = (ffi_arg)((void*(*)(void*, void*))(code))(arg1, arg2);
 
 	printf("res: 0x%08x\n", (unsigned int) res);
 	// { dg-output "\n0x01234567 0x89abcdef: 0x8acf1356" }
Index: testsuite/libffi.call/cls_schar.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_schar.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_schar.c
--- testsuite/libffi.call/cls_schar.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_schar.c	10 Jun 2009 10:29:31 -0000
@@ -21,19 +21,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   signed char res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_schar;
   cl_arg_types[1] = NULL;
 
@@ -41,9 +33,9 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_schar, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_schar_fn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_schar_fn, NULL, code)  == FFI_OK);
 
-  res = (*((cls_ret_schar)pcl))(127);
+  res = (*((cls_ret_schar)code))(127);
   /* { dg-output "127: 127" } */
   printf("res: %d\n", res);
   /* { dg-output "\nres: 127" } */
Index: testsuite/libffi.call/cls_sint.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_sint.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_sint.c
--- testsuite/libffi.call/cls_sint.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_sint.c	10 Jun 2009 10:29:31 -0000
@@ -19,19 +19,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   signed int res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_sint;
   cl_arg_types[1] = NULL;
 
@@ -39,9 +31,9 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_sint_fn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_sint_fn, NULL, code)  == FFI_OK);
 
-  res = (*((cls_ret_sint)pcl))(65534);
+  res = (*((cls_ret_sint)code))(65534);
   /* { dg-output "65534: 65534" } */
   printf("res: %d\n",res);
   /* { dg-output "\nres: 65534" } */
Index: testsuite/libffi.call/cls_sshort.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_sshort.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_sshort.c
--- testsuite/libffi.call/cls_sshort.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_sshort.c	10 Jun 2009 10:29:31 -0000
@@ -19,19 +19,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   signed short res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_sshort;
   cl_arg_types[1] = NULL;
 
@@ -39,9 +31,9 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_sshort, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_sshort_fn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_sshort_fn, NULL, code)  == FFI_OK);
 
-  res = (*((cls_ret_sshort)pcl))(255);
+  res = (*((cls_ret_sshort)code))(255);
   /* { dg-output "255: 255" } */
   printf("res: %d\n",res);
   /* { dg-output "\nres: 255" } */
Index: testsuite/libffi.call/cls_uchar.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_uchar.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_uchar.c
--- testsuite/libffi.call/cls_uchar.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_uchar.c	10 Jun 2009 10:29:31 -0000
@@ -19,19 +19,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   unsigned char res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_uchar;
   cl_arg_types[1] = NULL;
 
@@ -39,9 +31,9 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_uchar, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_uchar_fn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_uchar_fn, NULL, code)  == FFI_OK);
 
-  res = (*((cls_ret_uchar)pcl))(127);
+  res = (*((cls_ret_uchar)code))(127);
   /* { dg-output "127: 127" } */
   printf("res: %d\n",res);
   /* { dg-output "\nres: 127" } */
Index: testsuite/libffi.call/cls_uint.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_uint.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_uint.c
--- testsuite/libffi.call/cls_uint.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_uint.c	10 Jun 2009 10:29:31 -0000
@@ -20,19 +20,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   unsigned int res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_uint;
   cl_arg_types[1] = NULL;
 
@@ -40,9 +32,9 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_uint, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_uint_fn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_uint_fn, NULL, code)  == FFI_OK);
 
-  res = (*((cls_ret_uint)pcl))(2147483647);
+  res = (*((cls_ret_uint)code))(2147483647);
   /* { dg-output "2147483647: 2147483647" } */
   printf("res: %d\n",res);
   /* { dg-output "\nres: 2147483647" } */
Index: testsuite/libffi.call/cls_ulonglong.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_ulonglong.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_ulonglong.c
--- testsuite/libffi.call/cls_ulonglong.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_ulonglong.c	10 Jun 2009 10:29:31 -0000
@@ -12,7 +12,7 @@
 {
   *(unsigned long long *)resp=  *(unsigned long long *)args[0];
 
-  printf("%llu: %llu\n",*(unsigned long long *)args[0],
+  printf("%" PRIu64 ": %" PRIu64 "\n",*(unsigned long long *)args[0],
 	 *(unsigned long long *)(resp));
 }
 typedef unsigned long long (*cls_ret_ulonglong)(unsigned long long);
@@ -20,34 +20,26 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   unsigned long long res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_uint64;
   cl_arg_types[1] = NULL;
 
   /* Initialize the cif */
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_uint64, cl_arg_types) == FFI_OK);
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_ulonglong_fn, NULL)  == FFI_OK);
-  res = (*((cls_ret_ulonglong)pcl))(214LL);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_ulonglong_fn, NULL, code)  == FFI_OK);
+  res = (*((cls_ret_ulonglong)code))(214LL);
   /* { dg-output "214: 214" } */
-  printf("res: %lld\n", res);
+  printf("res: %" PRId64 "\n", res);
   /* { dg-output "\nres: 214" } */
 
-  res = (*((cls_ret_ulonglong)pcl))(9223372035854775808LL);
+  res = (*((cls_ret_ulonglong)code))(9223372035854775808LL);
   /* { dg-output "\n9223372035854775808: 9223372035854775808" } */
-  printf("res: %lld\n", res);
+  printf("res: %" PRId64 "\n", res);
   /* { dg-output "\nres: 9223372035854775808" } */
 
   exit(0);
Index: testsuite/libffi.call/cls_ushort.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/cls_ushort.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 cls_ushort.c
--- testsuite/libffi.call/cls_ushort.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/cls_ushort.c	10 Jun 2009 10:29:31 -0000
@@ -20,19 +20,11 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[2];
   unsigned short res;
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cl_arg_types[0] = &ffi_type_ushort;
   cl_arg_types[1] = NULL;
 
@@ -40,9 +32,9 @@
   CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_ushort, cl_arg_types) == FFI_OK);
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_ushort_fn, NULL)  == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_ushort_fn, NULL, code)  == FFI_OK);
 
-  res = (*((cls_ret_ushort)pcl))(65535);
+  res = (*((cls_ret_ushort)code))(65535);
   /* { dg-output "65535: 65535" } */
   printf("res: %d\n",res);
   /* { dg-output "\nres: 65535" } */
Index: testsuite/libffi.call/err_bad_abi.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/err_bad_abi.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 err_bad_abi.c
--- testsuite/libffi.call/err_bad_abi.c	8 Jun 2009 16:50:49 -0000	1.3
+++ testsuite/libffi.call/err_bad_abi.c	10 Jun 2009 10:29:31 -0000
@@ -15,19 +15,11 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args[1];
 	ffi_type* arg_types[1];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	arg_types[0] = NULL;
 	args[0] = NULL;
 
@@ -39,7 +31,7 @@
 
 	cif.abi= 255;
 
-	CHECK(ffi_prep_closure(pcl, &cif, dummy_fn, NULL) == FFI_BAD_ABI);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, dummy_fn, NULL, code) == FFI_BAD_ABI);
 
 	exit(0);
 }
Index: testsuite/libffi.call/err_bad_typedef.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/err_bad_typedef.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 err_bad_typedef.c
--- testsuite/libffi.call/err_bad_typedef.c	8 Jun 2009 16:50:49 -0000	1.2
+++ testsuite/libffi.call/err_bad_typedef.c	10 Jun 2009 10:29:31 -0000
@@ -10,18 +10,8 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
 	ffi_type* arg_types[1];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	arg_types[0] = NULL;
 
 	ffi_type	badType	= ffi_type_void;
Index: testsuite/libffi.call/float2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/float2.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 float2.c
--- testsuite/libffi.call/float2.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/float2.c	10 Jun 2009 10:29:31 -0000
@@ -4,7 +4,8 @@
    PR:		none.
    Originator:	From the original ffitest.c  */
 
-/* { dg-do run } */
+/* { dg-excess-errors { target x86_64-*-mingw* x86_64-*-cygwin* } } */
+/* { dg-do run { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
 
 #include "ffitest.h"
 #include "float.h"
Index: testsuite/libffi.call/huge_struct.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/huge_struct.c,v
retrieving revision 1.1
diff -u -b -w -r1.1 huge_struct.c
--- testsuite/libffi.call/huge_struct.c	5 Mar 2008 00:07:02 -0000	1.1
+++ testsuite/libffi.call/huge_struct.c	10 Jun 2009 10:29:31 -0000
@@ -5,8 +5,10 @@
 	Originator:		Blake Chaffin	6/18/2007
 */
 
+/* { dg-excess-errors { target x86_64-*-mingw* x86_64-*-cygwin* } } */
 /* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 /* { dg-options -mlong-double-128 { target powerpc64*-*-* } } */
+/* { dg-output "" { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
 
 #include <stdint.h>
 
@@ -120,23 +122,23 @@
 {
 	BigStruct	retVal	= {
 		ui8_1 + 1, si8_1 + 1, ui16_1 + 1, si16_1 + 1, ui32_1 + 1, si32_1 + 1,
-			ui64_1 + 1, si64_1 + 1, f_1 + 1, d_1 + 1, ld_1 + 1, (char*)((long)p_1 + 1), 
+			ui64_1 + 1, si64_1 + 1, f_1 + 1, d_1 + 1, ld_1 + 1, (char*)((intptr_t)p_1 + 1), 
 		ui8_2 + 2, si8_2 + 2, ui16_2 + 2, si16_2 + 2, ui32_2 + 2, si32_2 + 2,
-			ui64_2 + 2, si64_2 + 2, f_2 + 2, d_2 + 2, ld_2 + 2, (char*)((long)p_2 + 2), 
+			ui64_2 + 2, si64_2 + 2, f_2 + 2, d_2 + 2, ld_2 + 2, (char*)((intptr_t)p_2 + 2), 
 		ui8_3 + 3, si8_3 + 3, ui16_3 + 3, si16_3 + 3, ui32_3 + 3, si32_3 + 3,
-			ui64_3 + 3, si64_3 + 3, f_3 + 3, d_3 + 3, ld_3 + 3, (char*)((long)p_3 + 3), 
+			ui64_3 + 3, si64_3 + 3, f_3 + 3, d_3 + 3, ld_3 + 3, (char*)((intptr_t)p_3 + 3), 
 		ui8_4 + 4, si8_4 + 4, ui16_4 + 4, si16_4 + 4, ui32_4 + 4, si32_4 + 4,
-			ui64_4 + 4, si64_4 + 4, f_4 + 4, d_4 + 4, ld_4 + 4, (char*)((long)p_4 + 4), 
+			ui64_4 + 4, si64_4 + 4, f_4 + 4, d_4 + 4, ld_4 + 4, (char*)((intptr_t)p_4 + 4), 
 		ui8_5 + 5, si8_5 + 5};
 
-	printf("%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p %hhu %hhd: "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p %hhu %hhd\n",
+	printf("%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p %hhu %hhd: "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p %hhu %hhd\n",
 		ui8_1, si8_1, ui16_1, si16_1, ui32_1, si32_1, ui64_1, si64_1, f_1, d_1, ld_1, p_1,
 		ui8_2, si8_2, ui16_2, si16_2, ui32_2, si32_2, ui64_2, si64_2, f_2, d_2, ld_2, p_2,
 		ui8_3, si8_3, ui16_3, si16_3, ui32_3, si32_3, ui64_3, si64_3, f_3, d_3, ld_3, p_3,
@@ -154,7 +156,7 @@
 }
 
 static void
-cls_large_fn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_large_fn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* userdata __UNUSED__)
 {
 	uint8_t		ui8_1	= *(uint8_t*)args[0];
 	int8_t		si8_1	= *(int8_t*)args[1];
@@ -216,18 +218,10 @@
 }
 
 int
-main(int argc, const char** argv)
+main(int argc __UNUSED__, const char** argv __UNUSED__)
 {
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
-
-#ifdef USING_MMAP
-	pcl = allocate_mmap(sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 
 	ffi_cif		cif;
 	ffi_type*	argTypes[51];
@@ -302,10 +296,10 @@
 
 	ffi_call(&cif, FFI_FN(test_large_fn), &retVal, argValues);
 	// { dg-output "1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2: 2 3 4 5 6 7 8 9 10 11 12 0x12345679 3 4 5 6 7 8 9 10 11 12 13 0x1234567a 4 5 6 7 8 9 10 11 12 13 14 0x1234567b 5 6 7 8 9 10 11 12 13 14 15 0x1234567c 6 7" }
-	printf("res: %hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p %hhu %hhd\n",
+	printf("res: %hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p %hhu %hhd\n",
 		retVal.a, retVal.b, retVal.c, retVal.d, retVal.e, retVal.f,
 		retVal.g, retVal.h, retVal.i, retVal.j, retVal.k, retVal.l,
 		retVal.m, retVal.n, retVal.o, retVal.p, retVal.q, retVal.r,
@@ -316,24 +310,24 @@
 		retVal.qq, retVal.rr, retVal.ss, retVal.tt, retVal.uu, retVal.vv, retVal.ww, retVal.xx);
 	// { dg-output "\nres: 2 3 4 5 6 7 8 9 10 11 12 0x12345679 3 4 5 6 7 8 9 10 11 12 13 0x1234567a 4 5 6 7 8 9 10 11 12 13 14 0x1234567b 5 6 7 8 9 10 11 12 13 14 15 0x1234567c 6 7" }
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_large_fn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_large_fn, NULL, code) == FFI_OK);
 
 	retVal	= ((BigStruct(*)(
 		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
 		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
 		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
 		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
-		uint8_t, int8_t))(pcl))(
+		uint8_t, int8_t))(code))(
 		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
 		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
 		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
 		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
 		ui8, si8);
 	// { dg-output "\n1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2: 2 3 4 5 6 7 8 9 10 11 12 0x12345679 3 4 5 6 7 8 9 10 11 12 13 0x1234567a 4 5 6 7 8 9 10 11 12 13 14 0x1234567b 5 6 7 8 9 10 11 12 13 14 15 0x1234567c 6 7" }
-	printf("res: %hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p "
-		"%hhu %hhd %hu %hd %u %d %llu %lld %.0f %.0f %L.0f %p %hhu %hhd\n",
+	printf("res: %hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p "
+		"%hhu %hhd %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %L.0f %p %hhu %hhd\n",
 		retVal.a, retVal.b, retVal.c, retVal.d, retVal.e, retVal.f,
 		retVal.g, retVal.h, retVal.i, retVal.j, retVal.k, retVal.l,
 		retVal.m, retVal.n, retVal.o, retVal.p, retVal.q, retVal.r,
Index: testsuite/libffi.call/nested_struct.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 nested_struct.c
--- testsuite/libffi.call/nested_struct.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/nested_struct.c	10 Jun 2009 10:29:31 -0000
@@ -68,10 +68,8 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[5];
   ffi_type* cls_struct_fields1[5];
@@ -79,12 +77,6 @@
   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -143,12 +135,12 @@
   CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));
   CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_combined_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_combined_gn, NULL, code) == FFI_OK);
 
   res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1,
 				     cls_struct_16byte2,
 				     cls_struct_combined))
-	     (pcl))(e_dbl, f_dbl, g_dbl);
+	     (code))(e_dbl, f_dbl, g_dbl);
   /* { dg-output "\n9 2 6 1 2 3 4 5 6 3 1 8: 15 10 13 10 12 13" } */
   CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));
   CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));
Index: testsuite/libffi.call/nested_struct1.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct1.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 nested_struct1.c
--- testsuite/libffi.call/nested_struct1.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/nested_struct1.c	10 Jun 2009 10:29:31 -0000
@@ -72,10 +72,8 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[5];
   ffi_type* cls_struct_fields[5];
   ffi_type* cls_struct_fields1[5];
@@ -83,12 +81,6 @@
   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
   ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -150,13 +142,13 @@
   CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));
   CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));
 
-  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_combined_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_combined_gn, NULL, code) == FFI_OK);
 
   res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1,
 				     cls_struct_16byte2,
 				     cls_struct_combined,
 				     cls_struct_16byte1))
-	     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);
+	     (code))(e_dbl, f_dbl, g_dbl, h_dbl);
   /* { dg-output "\n9 2 6 1 2 3 4 5 6 3 1 8 3 2 4: 15 10 13 10 12 13" } */
   CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));
   CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));
Index: testsuite/libffi.call/nested_struct10.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct10.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 nested_struct10.c
--- testsuite/libffi.call/nested_struct10.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/nested_struct10.c	10 Jun 2009 10:29:31 -0000
@@ -58,10 +58,8 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[4];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[4];
@@ -69,12 +67,6 @@
   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
   ffi_type* dbl_arg_types[4];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -129,9 +121,9 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
   /* { dg-output "\n1 7 12 127 99 255 2 9: 270 242 143" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
Index: testsuite/libffi.call/nested_struct2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct2.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 nested_struct2.c
--- testsuite/libffi.call/nested_struct2.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/nested_struct2.c	10 Jun 2009 10:29:31 -0000
@@ -49,22 +49,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
   ffi_type cls_struct_type, cls_struct_type1;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -106,9 +98,9 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
   /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
Index: testsuite/libffi.call/nested_struct3.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct3.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 nested_struct3.c
--- testsuite/libffi.call/nested_struct3.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/nested_struct3.c	10 Jun 2009 10:29:31 -0000
@@ -50,22 +50,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
   ffi_type cls_struct_type, cls_struct_type1;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -108,9 +100,9 @@
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
 
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
   /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
Index: testsuite/libffi.call/nested_struct4.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct4.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 nested_struct4.c
--- testsuite/libffi.call/nested_struct4.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/nested_struct4.c	10 Jun 2009 10:29:31 -0000
@@ -50,22 +50,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
   ffi_type cls_struct_type, cls_struct_type1;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -107,9 +99,9 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
   /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
Index: testsuite/libffi.call/nested_struct5.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct5.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 nested_struct5.c
--- testsuite/libffi.call/nested_struct5.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/nested_struct5.c	10 Jun 2009 10:29:31 -0000
@@ -50,22 +50,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
   ffi_type cls_struct_type, cls_struct_type1;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -108,9 +100,9 @@
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
 
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
   /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
Index: testsuite/libffi.call/nested_struct6.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct6.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 nested_struct6.c
--- testsuite/libffi.call/nested_struct6.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/nested_struct6.c	10 Jun 2009 10:29:31 -0000
@@ -57,10 +57,8 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[4];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
@@ -68,12 +66,6 @@
   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
   ffi_type* dbl_arg_types[4];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -127,9 +119,9 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
   /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
Index: testsuite/libffi.call/nested_struct7.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct7.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 nested_struct7.c
--- testsuite/libffi.call/nested_struct7.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/nested_struct7.c	10 Jun 2009 10:29:31 -0000
@@ -50,22 +50,14 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[3];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
   ffi_type cls_struct_type, cls_struct_type1;
   ffi_type* dbl_arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -107,9 +99,9 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
   /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
Index: testsuite/libffi.call/nested_struct8.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct8.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 nested_struct8.c
--- testsuite/libffi.call/nested_struct8.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/nested_struct8.c	10 Jun 2009 10:29:31 -0000
@@ -57,10 +57,8 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[4];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
@@ -68,12 +66,6 @@
   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
   ffi_type* dbl_arg_types[4];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -127,9 +119,9 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
   /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
Index: testsuite/libffi.call/nested_struct9.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/nested_struct9.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 nested_struct9.c
--- testsuite/libffi.call/nested_struct9.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/nested_struct9.c	10 Jun 2009 10:29:31 -0000
@@ -57,10 +57,8 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args_dbl[4];
   ffi_type* cls_struct_fields[3];
   ffi_type* cls_struct_fields1[3];
@@ -68,12 +66,6 @@
   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
   ffi_type* dbl_arg_types[4];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   cls_struct_type.size = 0;
   cls_struct_type.alignment = 0;
   cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -127,9 +119,9 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
 
-  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
 
-  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
   /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
Index: testsuite/libffi.call/problem1.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/problem1.c,v
retrieving revision 1.3
diff -u -b -w -r1.3 problem1.c
--- testsuite/libffi.call/problem1.c	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.call/problem1.c	10 Jun 2009 10:29:31 -0000
@@ -45,19 +45,11 @@
   ffi_type* my_ffi_struct_fields[4];
   ffi_type my_ffi_struct_type;
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
   void* args[4];
   ffi_type* arg_types[3];
 
-#ifdef USING_MMAP
-  pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
-
   struct my_ffi_struct g = { 1.0, 2.0, 3.0 };
   struct my_ffi_struct f = { 1.0, 2.0, 3.0 };
   struct my_ffi_struct res;
@@ -87,9 +79,9 @@
   printf("res: %g %g %g\n", res.a, res.b, res.c);
   /* { dg-output "\nres: 2 4 6" } */
 
-  CHECK(ffi_prep_closure(pcl, &cif, stub, NULL) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, stub, NULL, code) == FFI_OK);
 
-  res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(pcl))(g, f);
+  res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(code))(g, f);
   /* { dg-output "\n1 2 3 1 2 3: 2 4 6" } */
   printf("res: %g %g %g\n", res.a, res.b, res.c);
   /* { dg-output "\nres: 2 4 6" } */
Index: testsuite/libffi.call/return_ldl.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/return_ldl.c,v
retrieving revision 1.1
diff -u -b -w -r1.1 return_ldl.c
--- testsuite/libffi.call/return_ldl.c	29 Jan 2008 15:16:43 -0000	1.1
+++ testsuite/libffi.call/return_ldl.c	10 Jun 2009 10:29:31 -0000
@@ -4,7 +4,7 @@
    PR:		none.
    Originator:	<andreast@gcc.gnu.org> 20071113  */
 
-/* { dg-do run } */
+/* { dg-do run { xfail x86_64-*-mingw* x86_64-*-cygwin* } } */
 #include "ffitest.h"
 
 static long double return_ldl(long double ldl)
Index: testsuite/libffi.call/return_ll1.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/return_ll1.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 return_ll1.c
--- testsuite/libffi.call/return_ll1.c	29 Jan 2008 15:15:20 -0000	1.2
+++ testsuite/libffi.call/return_ll1.c	10 Jun 2009 10:29:31 -0000
@@ -36,7 +36,7 @@
   ll2 = 11111111;
 
   ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
-  printf("res: %lld, %lld\n", rlonglong, ll0 + ll1 + ll2);
+  printf("res: %" PRId64 ", %" PRId64 "\n", rlonglong, ll0 + ll1 + ll2);
   /* { dg-output "res: 11111133333222, 11111133333222" } */
   exit(0);
 }
Index: testsuite/libffi.call/stret_large.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/stret_large.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 stret_large.c
--- testsuite/libffi.call/stret_large.c	8 Jun 2009 16:50:49 -0000	1.2
+++ testsuite/libffi.call/stret_large.c	10 Jun 2009 10:29:31 -0000
@@ -75,21 +75,13 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args_dbl[5];
 	ffi_type* cls_struct_fields[15];
 	ffi_type cls_struct_type;
 	ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	cls_struct_type.size = 0;
 	cls_struct_type.alignment = 0;
 	cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -139,10 +131,10 @@
 		res_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n);
 	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 16" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_struct_108byte_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_108byte_gn, NULL, code) == FFI_OK);
 
 	res_dbl = ((struct_108byte(*)(struct_108byte, struct_108byte,
-		struct_108byte, struct_108byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);
+		struct_108byte, struct_108byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
 	/* { dg-output "\n22 15 17 25 6 13 19 18 22 15 17 25 6 16" } */
 	printf("res: %g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", res_dbl.a, res_dbl.b,
 		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,
Index: testsuite/libffi.call/stret_large2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/stret_large2.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 stret_large2.c
--- testsuite/libffi.call/stret_large2.c	8 Jun 2009 16:50:49 -0000	1.2
+++ testsuite/libffi.call/stret_large2.c	10 Jun 2009 10:29:31 -0000
@@ -77,21 +77,13 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args_dbl[5];
 	ffi_type* cls_struct_fields[16];
 	ffi_type cls_struct_type;
 	ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	cls_struct_type.size = 0;
 	cls_struct_type.alignment = 0;
 	cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -142,10 +134,10 @@
 		res_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n, res_dbl.o);
 	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 26 16" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_struct_116byte_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_116byte_gn, NULL, code) == FFI_OK);
 
 	res_dbl = ((struct_116byte(*)(struct_116byte, struct_116byte,
-		struct_116byte, struct_116byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);
+		struct_116byte, struct_116byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
 	/* { dg-output "\n22 15 17 25 6 13 19 18 22 15 17 25 6 26 16" } */
 	printf("res: %g %g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", res_dbl.a, res_dbl.b,
 		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,
Index: testsuite/libffi.call/stret_medium.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/stret_medium.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 stret_medium.c
--- testsuite/libffi.call/stret_medium.c	8 Jun 2009 16:50:49 -0000	1.2
+++ testsuite/libffi.call/stret_medium.c	10 Jun 2009 10:29:31 -0000
@@ -61,21 +61,13 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args_dbl[5];
 	ffi_type* cls_struct_fields[10];
 	ffi_type cls_struct_type;
 	ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	cls_struct_type.size = 0;
 	cls_struct_type.alignment = 0;
 	cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -119,10 +111,10 @@
 		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
 	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 16" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_struct_72byte_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_72byte_gn, NULL, code) == FFI_OK);
 
 	res_dbl = ((struct_72byte(*)(struct_72byte, struct_72byte,
-		struct_72byte, struct_72byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);
+		struct_72byte, struct_72byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
 	/* { dg-output "\n22 15 17 25 6 13 19 18 16" } */
 	printf("res: %g %g %g %g %g %g %g %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c,
 		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
Index: testsuite/libffi.call/stret_medium2.c
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.call/stret_medium2.c,v
retrieving revision 1.2
diff -u -b -w -r1.2 stret_medium2.c
--- testsuite/libffi.call/stret_medium2.c	8 Jun 2009 16:50:49 -0000	1.2
+++ testsuite/libffi.call/stret_medium2.c	10 Jun 2009 10:29:31 -0000
@@ -39,7 +39,7 @@
 	result.h = b0.h + b1.h + b2.h + b3.h;
 	result.i = b0.i + b1.i + b2.i + b3.i;
 
-	printf("%g %g %g %g %g %g %g %g %lld\n", result.a, result.b, result.c,
+	printf("%g %g %g %g %g %g %g %g %" PRId64 "\n", result.a, result.b, result.c,
 		result.d, result.e, result.f, result.g, result.h, result.i);
 
 	return result;
@@ -61,21 +61,13 @@
 int main (void)
 {
 	ffi_cif cif;
-#ifndef USING_MMAP
-	static ffi_closure cl;
-#endif
-	ffi_closure *pcl;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
 	void* args_dbl[5];
 	ffi_type* cls_struct_fields[10];
 	ffi_type cls_struct_type;
 	ffi_type* dbl_arg_types[5];
 
-#ifdef USING_MMAP
-	pcl = allocate_mmap (sizeof(ffi_closure));
-#else
-	pcl = &cl;
-#endif
-
 	cls_struct_type.size = 0;
 	cls_struct_type.alignment = 0;
 	cls_struct_type.type = FFI_TYPE_STRUCT;
@@ -115,16 +107,16 @@
 
 	ffi_call(&cif, FFI_FN(cls_struct_72byte_fn), &res_dbl, args_dbl);
 	/* { dg-output "22 15 17 25 6 13 19 18 16" } */
-	printf("res: %g %g %g %g %g %g %g %g %lld\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	printf("res: %g %g %g %g %g %g %g %g %" PRId64 "\n", res_dbl.a, res_dbl.b, res_dbl.c,
 		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
 	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 16" } */
 
-	CHECK(ffi_prep_closure(pcl, &cif, cls_struct_72byte_gn, NULL) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_72byte_gn, NULL, code) == FFI_OK);
 
 	res_dbl = ((struct_72byte(*)(struct_72byte, struct_72byte,
-		struct_72byte, struct_72byte))(pcl))(e_dbl, f_dbl, g_dbl, h_dbl);
+		struct_72byte, struct_72byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
 	/* { dg-output "\n22 15 17 25 6 13 19 18 16" } */
-	printf("res: %g %g %g %g %g %g %g %g %lld\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	printf("res: %g %g %g %g %g %g %g %g %" PRId64 "\n", res_dbl.a, res_dbl.b, res_dbl.c,
 		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
 	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 16" } */
 
Index: testsuite/libffi.special/unwindtest.cc
===================================================================
RCS file: /cvs/libffi/libffi/testsuite/libffi.special/unwindtest.cc,v
retrieving revision 1.3
diff -u -b -w -r1.3 unwindtest.cc
--- testsuite/libffi.special/unwindtest.cc	29 Jan 2008 15:15:20 -0000	1.3
+++ testsuite/libffi.special/unwindtest.cc	10 Jun 2009 10:29:31 -0000
@@ -27,7 +27,7 @@
       (int)(*(double*)args[8]) + (int)*(int *)args[9] +
       (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
       (int)*(int *)args[12] + (int)(*(int *)args[13]) +
-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;
+      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(intptr_t)userdata;
 
     printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
 	   (int)*(float *)args[0], (int)(*(float *)args[1]),
@@ -38,7 +38,7 @@
 	   (int)(*(int *)args[10]), (int)(*(float *)args[11]),
 	   (int)*(int *)args[12], (int)(*(int *)args[13]),
 	   (int)(*(int *)args[14]), *(int *)args[15],
-	   (int)(long)userdata, (int)*(ffi_arg*)resp);
+	   (int)(intptr_t)userdata, (int)*(ffi_arg*)resp);
 
     throw (int)*(ffi_arg*)resp;
 }
@@ -50,27 +50,20 @@
 int main (void)
 {
   ffi_cif cif;
-#ifndef USING_MMAP
-  static ffi_closure cl;
-#endif
-  ffi_closure *pcl;
+  void *code;
+  ffi_closure *pcl = (ffi_closure *)ffi_closure_alloc(sizeof(ffi_closure), &code);
   ffi_type * cl_arg_types[17];
-#ifdef USING_MMAP
-  pcl = (ffi_closure *) allocate_mmap (sizeof(ffi_closure));
-#else
-  pcl = &cl;
-#endif
 
   {
     cl_arg_types[1] = NULL;
 
     CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0,
 		       &ffi_type_void, cl_arg_types) == FFI_OK);
-    CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn, NULL) == FFI_OK);
+    CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn, NULL, code) == FFI_OK);
 
     try
       {
-	(*((closure_test_type)(pcl)))();
+	(*((closure_test_type)(code)))();
       } catch (int exception_code)
       {
 	CHECK(exception_code == 9);
@@ -104,11 +97,11 @@
       CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
 			 &ffi_type_sint, cl_arg_types) == FFI_OK);
 
-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,
-			     (void *) 3 /* userdata */)  == FFI_OK);
+      CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn1,
+                                 (void *) 3 /* userdata */, code)  == FFI_OK);
       try
 	{
-	  (*((closure_test_type1)pcl))
+	  (*((closure_test_type1)code))
 	    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,
 	     19, 21, 1);
 	  /* { dg-output "\n1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255" } */
